/*
* Copyright (c) 2018 Next Limit S.L.
*
* This file is part of The-Forge
* (see https://github.com/ConfettiFX/The-Forge).
*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

#ifdef OPENGL

#define RENDERER_IMPLEMENTATION
#define MAX_FRAMES_IN_FLIGHT 2U

#include "OpenGL.h"

// GLEW/GLFW
#include "../../ThirdParty/OpenSource/GLFW/src/internal.h"

#include "../IRenderer.h"
#include "../../OS/Interfaces/ILogManager.h"

#include "../../OS/Interfaces/IMemoryManager.h"

// Autogenerated GlCmd abstraction
#include "glcorearbcmd.h"

#if !defined(__ANDROID__)
// Prefer Higher Performance GPU on switchable GPU systems
extern "C"
{
	__declspec(dllexport) DWORD	NvOptimusEnablement = 1;
	__declspec(dllexport) int	AmdPowerXpressRequestHighPerformance = 1;
}
#endif

extern void gl_createShaderReflection(const uint8_t* code, uint32_t shaderSize, ShaderStage shaderStage, ShaderReflection* pOutReflection);

//extern long gl_createBuffer(MemoryAllocator* pAllocator, const BufferCreateInfo* pCreateInfo, const AllocatorMemoryRequirements* pMemoryRequirements, Buffer* pBuffer);
//extern void gl_destroyBuffer(MemoryAllocator* pAllocator, struct Buffer* pBuffer);
//extern long gl_createTexture(MemoryAllocator* pAllocator, const TextureCreateInfo* pCreateInfo, const AllocatorMemoryRequirements* pMemoryRequirements, Texture* pTexture);
//extern void gl_destroyTexture(MemoryAllocator* pAllocator, struct Texture* pTexture);

void GLAPIENTRY MessageCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam)
{
	switch (type) {
	case GL_DEBUG_TYPE_ERROR:
	case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: {
		LOGERRORF("GL CALLBACK: %s type = 0x%x, severity = 0x%x, message = %s\n",
			(type == GL_DEBUG_TYPE_ERROR ? "** GL ERROR **" : ""), type, severity, message);
	} break;
	}
}

#define GL_UNKNOWN 0

static const GLint gGLBlendOpTranslator[BlendMode::MAX_BLEND_MODES] =
{
	//GL_BLEND_OP_ADD,
	//GL_BLEND_OP_SUBTRACT,
	//GL_BLEND_OP_REV_SUBTRACT,
	//GL_BLEND_OP_MIN,
	//GL_BLEND_OP_MAX,
};

static const GLint gGLBlendConstantTranslator[BlendConstant::MAX_BLEND_CONSTANTS] =
{
	//GL_BLEND_ZERO,
	//GL_BLEND_ONE,
	//GL_BLEND_SRC_COLOR,
	//GL_BLEND_INV_SRC_COLOR,
	//GL_BLEND_DEST_COLOR,
	//GL_BLEND_INV_DEST_COLOR,
	//GL_BLEND_SRC_ALPHA,
	//GL_BLEND_INV_SRC_ALPHA,
	//GL_BLEND_DEST_ALPHA,
	//GL_BLEND_INV_DEST_ALPHA,
	//GL_BLEND_SRC_ALPHA_SAT,
	//GL_BLEND_BLEND_FACTOR,
	//GL_BLEND_INV_BLEND_FACTOR,
};

static const GLint gGLStencilOpTranslator[StencilOp::MAX_STENCIL_OPS] =
{
	//OPENGL_STENCIL_OP_KEEP,
	//OPENGL_STENCIL_OP_ZERO,
	//OPENGL_STENCIL_OP_REPLACE,
	//OPENGL_STENCIL_OP_INVERT,
	//OPENGL_STENCIL_OP_INCR,
	//OPENGL_STENCIL_OP_DECR,
	//OPENGL_STENCIL_OP_INCR_SAT,
	//OPENGL_STENCIL_OP_DECR_SAT,
};

static const GLint gGLCullModeTranslator[] =
{
	GL_UNKNOWN,
	GL_BACK,
	GL_FRONT,
};

static const GLint gGLPolygonModeTranslator[] =
{
	GL_FILL,
	GL_LINE,
};

static const GLint gGLTexImageInternalFormatTranslator[] =
{
	GL_UNKNOWN,

	// Unsigned formats
	GL_R8,
	GL_RG8,
	GL_RGB8,
	GL_RGBA8,

	GL_R16,
	GL_RG16,
	GL_RGB16,
	GL_RGBA16,

	// Signed formats
	GL_R8_SNORM,
	GL_RG8_SNORM,
	GL_RGB8_SNORM,
	GL_RGBA8_SNORM,

	GL_R16_SNORM,
	GL_RG16_SNORM,
	GL_RGB16_SNORM,
	GL_RGBA16_SNORM,

	// Float formats
	GL_R16F,
	GL_RG16F,
	GL_RGB16F,
	GL_RGBA16F,

	GL_R32F,
	GL_RG32F,
	GL_RGB32F,
	GL_RGBA32F,

	// Signed integer formats
	GL_R16I,
	GL_RG16I,
	GL_RGB16I,
	GL_RGBA16I,

	GL_R32I,
	GL_RG32I,
	GL_RGB32I,
	GL_RGBA32I,

	// Unsigned integer formats
	GL_R16UI,
	GL_RG16UI,
	GL_RGB16UI,
	GL_RGBA16UI,

	GL_R32UI,
	GL_RG32UI,
	GL_RGB32UI,
	GL_RGBA32UI,

	// Packed formats
	GL_UNKNOWN,
	GL_RGB9_E5,
	GL_R11F_G11F_B10F,
	GL_UNKNOWN,
	GL_RGBA4,
	GL_RGB10_A2,

	// Depth formats
	GL_DEPTH_COMPONENT16,
	GL_DEPTH_COMPONENT24,
	GL_DEPTH24_STENCIL8,
	GL_DEPTH_COMPONENT32,

	// Compressed formats
	GL_RGB,
	GL_RGBA,
	GL_RGBA,
	GL_UNKNOWN,
	GL_UNKNOWN,

	// PVR formats
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,

	//http://aras-p.info/texts/D3D9GPUHacks.html
	GL_UNKNOWN,

	//	XBox 360 specific fron buffer formats. NOt listed in other renderers. Please, add them when extend this structure.
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,

	// compressed mobile forms
	GL_RGB,
	GL_RGB,
	GL_RGBA,
	GL_RGBA,

	//http://aras-p.info/texts/D3D9GPUHacks.html
	GL_DEPTH_COMPONENT,
	GL_DEPTH_COMPONENT,
	GL_UNKNOWN,

	// BC1 == DXT1
	// BC2 == DXT2
	// BC3 == DXT4 / 5
	// BC4 == ATI1 == One color channel (8 bits)
	// BC5 == ATI2 == Two color channels (8 bits:8 bits)
	// BC6 == Three color channels (16 bits:16 bits:16 bits) in "half" floating point*
	// BC7 == Three color channels (4 to 7 bits per channel) with 0 to 8 bits of alpha
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	// Reveser Form
	GL_RGBA8,

	// Extend for DXGI
	GL_DEPTH32F_STENCIL8,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_DEPTH32F_STENCIL8
};

static const GLenum gGLTexImageFormatTranslator[] =
{
	GL_UNKNOWN,

	// Unsigned formats
	GL_RED,
	GL_RG,
	GL_RGB,
	GL_RGBA,

	GL_RED,
	GL_RG,
	GL_RGB,
	GL_RGBA,

	// Signed formats
	GL_RED,
	GL_RG,
	GL_RGB,
	GL_RGBA,

	GL_RED,
	GL_RG,
	GL_RGB,
	GL_RGBA,

	// Float formats
	GL_RED,
	GL_RG,
	GL_RGB,
	GL_RGBA,

	GL_RED,
	GL_RG,
	GL_RGB,
	GL_RGBA,

	// Signed integer formats
	GL_RED_INTEGER,
	GL_RG_INTEGER,
	GL_RGB_INTEGER,
	GL_RGBA_INTEGER,

	GL_RED_INTEGER,
	GL_RG_INTEGER,
	GL_RGB_INTEGER,
	GL_RGBA_INTEGER,

	// Unsigned integer formats
	GL_RED_INTEGER,
	GL_RG_INTEGER,
	GL_RGB_INTEGER,
	GL_RGBA_INTEGER,

	GL_RED_INTEGER,
	GL_RG_INTEGER,
	GL_RGB_INTEGER,
	GL_RGBA_INTEGER,

	// Packed formats
	GL_RGB,
	GL_RGB,
	GL_RGB,
	GL_RGB,
	GL_RGBA,
	GL_RGBA,

	// Depth formats
	GL_DEPTH_COMPONENT,
	GL_DEPTH_COMPONENT,
	GL_DEPTH_STENCIL,
	GL_DEPTH_COMPONENT,

	// Compressed formats
	GL_RGB,
	GL_RGBA,
	GL_RGBA,
	GL_UNKNOWN,
	GL_UNKNOWN,

	// PVR formats
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,

	//http://aras-p.info/texts/D3D9GPUHacks.html
	GL_UNKNOWN,

	//	XBox 360 specific fron buffer formats. NOt listed in other renderers. Please, add them when extend this structure.
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,

	// compressed mobile forms
	GL_RGB,
	GL_RGB,
	GL_RGBA,
	GL_RGBA,

	//http://aras-p.info/texts/D3D9GPUHacks.html
	GL_DEPTH_COMPONENT,
	GL_DEPTH_COMPONENT,
	GL_STENCIL_INDEX,

	// BC1 == DXT1
	// BC2 == DXT2
	// BC3 == DXT4 / 5
	// BC4 == ATI1 == One color channel (8 bits)
	// BC5 == ATI2 == Two color channels (8 bits:8 bits)
	// BC6 == Three color channels (16 bits:16 bits:16 bits) in "half" floating point*
	// BC7 == Three color channels (4 to 7 bits per channel) with 0 to 8 bits of alpha
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	// Reveser Form
	GL_BGRA,

	// Extend for DXGI
	GL_UNKNOWN,
	GL_STENCIL_INDEX,
	GL_DEPTH_STENCIL,
	GL_DEPTH_STENCIL
};

static const GLenum gGLTexImageTypeTranslator[] =
{
	GL_UNKNOWN,

	// Unsigned formats
	GL_UNSIGNED_BYTE,
	GL_UNSIGNED_BYTE,
	GL_UNSIGNED_BYTE,
	GL_UNSIGNED_BYTE,

	GL_UNSIGNED_SHORT,
	GL_UNSIGNED_SHORT,
	GL_UNSIGNED_SHORT,
	GL_UNSIGNED_SHORT,

	// Signed formats
	GL_BYTE,
	GL_BYTE,
	GL_BYTE,
	GL_BYTE,

	GL_SHORT,
	GL_SHORT,
	GL_SHORT,
	GL_SHORT,

	// Float formats
	GL_FLOAT,
	GL_FLOAT,
	GL_FLOAT,
	GL_FLOAT,

	GL_FLOAT,
	GL_FLOAT,
	GL_FLOAT,
	GL_FLOAT,

	// Signed integer formats
	GL_SHORT,
	GL_SHORT,
	GL_SHORT,
	GL_SHORT,

	GL_INT,
	GL_INT,
	GL_INT,
	GL_INT,

	// Unsigned integer formats
	GL_UNSIGNED_SHORT,
	GL_UNSIGNED_SHORT,
	GL_UNSIGNED_SHORT,
	GL_UNSIGNED_SHORT,

	GL_UNSIGNED_INT,
	GL_UNSIGNED_INT,
	GL_UNSIGNED_INT,
	GL_UNSIGNED_INT,

	// Packed formats
	GL_UNKNOWN,
	GL_RGB9_E5,
	GL_UNSIGNED_INT_10F_11F_11F_REV,
	GL_UNSIGNED_SHORT_5_6_5,
	GL_UNSIGNED_SHORT_4_4_4_4,
	GL_UNSIGNED_INT_10_10_10_2,

	// Depth formats
	GL_FLOAT,
	GL_FLOAT,
	GL_FLOAT,
	GL_FLOAT,

	// Compressed formats
	GL_RGB,
	GL_RGBA,
	GL_RGBA,
	GL_UNKNOWN,
	GL_UNKNOWN,

	// PVR formats
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,

	//http://aras-p.info/texts/D3D9GPUHacks.html
	GL_UNKNOWN,

	//	XBox 360 specific fron buffer formats. NOt listed in other renderers. Please, add them when extend this structure.
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,

	// compressed mobile forms
	GL_RGB,
	GL_RGB,
	GL_RGBA,
	GL_RGBA,

	//http://aras-p.info/texts/D3D9GPUHacks.html
	GL_DEPTH_COMPONENT,
	GL_DEPTH_COMPONENT,
	GL_UNKNOWN,

	// BC1 == DXT1
	// BC2 == DXT2
	// BC3 == DXT4 / 5
	// BC4 == ATI1 == One color channel (8 bits)
	// BC5 == ATI2 == Two color channels (8 bits:8 bits)
	// BC6 == Three color channels (16 bits:16 bits:16 bits) in "half" floating point*
	// BC7 == Three color channels (4 to 7 bits per channel) with 0 to 8 bits of alpha
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_UNKNOWN,
	// Reveser Form
	GL_RGBA8,

	// Extend for DXGI
	GL_DEPTH32F_STENCIL8,
	GL_UNKNOWN,
	GL_UNKNOWN,
	GL_DEPTH32F_STENCIL8
};

// =================================================================================================
// IMPLEMENTATION
// =================================================================================================

#if defined(RENDERER_IMPLEMENTATION)

#pragma comment(lib, "opengl32.lib")

#ifdef _DEBUG
#pragma comment(lib, "glew32sd.lib")
#else
#pragma comment(lib, "glew32s.lib")
#endif

#define SAFE_FREE(p_var)			\
	if (p_var) {					\
		conf_free(p_var);			\
	}

#if defined(__cplusplus)
#define DECLARE_ZERO(type, var)		\
	type var = {};
#else
#define DECLARE_ZERO(type, var)		\
	type var = {0};
#endif

#define SAFE_RELEASE(p_var)			\
	if (p_var) {					\
		p_var->Release();			\
		p_var = NULL;				\
	}

/************************************************************************/
// Context State
/************************************************************************/
struct GlColor {
	GLfloat mRed;
	GLfloat mGreen;
	GLfloat mBlue;
	GLfloat mAlpha;
};

struct GlRectangle {
	GLint mX;
	GLint mY;
	GLsizei mWidth;
	GLsizei mHeight;
};

struct GlContextState {
	bool							mEnableDepthTest;
	GLboolean						mDepthMask;
	GLenum							mDrawBuffer;
	GlRectangle						mScissor;
	GlRectangle						mViewport;
	GlColor							mClearColor;
	GLfloat							mClearDepth;
	GLint							mClearStencil;
	GLenum							mDrawPrimitiveMode;
	GLuint							mProgram;
};

/************************************************************************/
// Descriptor State
/************************************************************************/
struct GlDescriptorSampler {
	DescriptorType sType;
	GLuint mSampler;
};

struct GlDescriptorBuffer {
	DescriptorType sType;
	GLuint mIndex;
	GLuint mBuffer;
	GLintptr mOffset;
	GLsizeiptr mSize;
};

struct GlDescriptorImage {
	DescriptorType sType;
	GLuint mTexture;
};

struct GlDescriptorRootConstant {
	DescriptorType sType;
};

struct GlDescriptor {
	union {
		GlDescriptorSampler			mSsampler;
		GlDescriptorImage			mImage;
		GlDescriptorBuffer			mBuffer;
		GlDescriptorRootConstant	mRootConstant;
	};
};

/************************************************************************/
// Descriptor State Manager
/************************************************************************/
using GlDescriptorMap = tinystl::unordered_map<uint64_t, GlDescriptor*>;
using GlDescriptorMapConstIterator = tinystl::unordered_map<uint64_t, GlDescriptor*>::const_iterator;
using GlDescriptorMapNode = tinystl::unordered_hash_node<uint64_t, GlDescriptor*>;
using GlDescriptorNameToIndexMap = tinystl::unordered_map<uint32_t, uint32_t>;

struct DescriptorManager
{
	/// The root signature associated with this descriptor manager
	RootSignature*				pRootSignature;
	/// Array of buffer descriptors per update frequency.
	GlDescriptorBuffer*			pBufferInfo[DESCRIPTOR_UPDATE_FREQ_COUNT];
	/// Array of image descriptors per update frequency
	GlDescriptorImage*			pImageInfo[DESCRIPTOR_UPDATE_FREQ_COUNT];
	/// Double buffered Hash map to check if a descriptor table with a descriptor hash already exists to avoid redundant copy descriptors operations
	GlDescriptorMap				mStaticDescriptorMap[MAX_FRAMES_IN_FLIGHT];

	Cmd*						pCurrentCmd;
	uint32_t					mFrameIdx;
};

Mutex gDescriptorMutex;

static void add_descriptor_manager(Renderer* pRenderer, RootSignature* pRootSignature, DescriptorManager** ppManager)
{
	DescriptorManager* pManager = (DescriptorManager*)conf_calloc(1, sizeof(*pManager));
	pManager->pRootSignature = pRootSignature;
	pManager->mFrameIdx = -1;

	const uint32_t setCount = DESCRIPTOR_UPDATE_FREQ_COUNT;

	for (uint32_t setIndex = 0; setIndex < setCount; ++setIndex)
	{
		const DescriptorSetLayout* layout = &pRootSignature->pGlDescriptorSetLayouts[setIndex];
		const uint32_t descCount = layout->mDescriptorCount;

		if (!descCount)
			continue;

		if (layout->mCumulativeBufferDescriptorCount)
			pManager->pBufferInfo[setIndex] = (GlDescriptorBuffer*)conf_calloc(layout->mCumulativeBufferDescriptorCount, sizeof(GlDescriptorBuffer));
		if (layout->mCumulativeImageDescriptorCount)
			pManager->pImageInfo[setIndex] = (GlDescriptorImage*)conf_calloc(layout->mCumulativeImageDescriptorCount, sizeof(GlDescriptorImage));

		// Fill the write descriptors with default values during initialize so the only thing we change in cmdBindDescriptors is the the VkBuffer / VkImageView objects
		for (uint32_t i = 0; i < descCount; ++i)
		{
			const DescriptorInfo* pDesc = &pRootSignature->pDescriptors[layout->pDescriptorIndices[i]];

			if (pDesc->mDesc.type == DESCRIPTOR_TYPE_SAMPLER)
			{
				for (uint32_t arr = 0; arr < pDesc->mDesc.size; ++arr)
					pManager->pImageInfo[setIndex][pDesc->mHandleIndex + arr].mTexture = 0;
			}
			else if (pDesc->mDesc.type == DESCRIPTOR_TYPE_TEXTURE || pDesc->mDesc.type == DESCRIPTOR_TYPE_RW_TEXTURE)
			{
				for (uint32_t arr = 0; arr < pDesc->mDesc.size; ++arr)
					pManager->pImageInfo[setIndex][pDesc->mHandleIndex + arr].mTexture = 0;
			}
			else
			{
				for (uint32_t arr = 0; arr < pDesc->mDesc.size; ++arr) {
					pManager->pBufferInfo[setIndex][pDesc->mHandleIndex + arr].mBuffer = 0;
					pManager->pBufferInfo[setIndex][pDesc->mHandleIndex + arr].mOffset = 0;
				}
			}
		}
	}

	*ppManager = pManager;
}

static void remove_descriptor_manager(Renderer* pRenderer, RootSignature* pRootSignature, DescriptorManager* pManager)
{
	const uint32_t setCount = DESCRIPTOR_UPDATE_FREQ_COUNT;
	const uint32_t frameCount = MAX_FRAMES_IN_FLIGHT;

	// Clean up all allocated descriptor sets
	for (uint32_t frameIdx = 0; frameIdx < frameCount; ++frameIdx)
	{
		pManager->mStaticDescriptorMap[frameIdx].~GlDescriptorMap();
	}

	for (uint32_t setIndex = 0; setIndex < setCount; ++setIndex)
	{
		const DescriptorSetLayout* layout = &pRootSignature->pGlDescriptorSetLayouts[setIndex];
		const uint32_t descCount = layout->mDescriptorCount;

		if (descCount)
		{
			SAFE_FREE(pManager->pBufferInfo[setIndex]);
			SAFE_FREE(pManager->pImageInfo[setIndex]);
		}
	}

	SAFE_FREE(pManager);
}

// This function returns the descriptor manager belonging to this thread
// If a descriptor manager does not exist for this thread, a new one is created
// With this approach we make sure that descriptor binding is thread safe and lock conf_free at the same time
static DescriptorManager* get_descriptor_manager(Renderer* pRenderer, RootSignature* pRootSignature)
{
	tinystl::unordered_hash_node<ThreadID, DescriptorManager*>* pNode = pRootSignature->pDescriptorManagerMap.find(Thread::GetCurrentThreadID()).node;
	if (pNode == NULL)
	{
		// Only need a lock when creating a new descriptor manager for this thread
		MutexLock lock(gDescriptorMutex);
		DescriptorManager* pManager = NULL;
		add_descriptor_manager(pRenderer, pRootSignature, &pManager);
		pRootSignature->pDescriptorManagerMap.insert({ Thread::GetCurrentThreadID(), pManager });
		return pManager;
	}
	else
	{
		return pNode->second;
	}
}

const DescriptorInfo* get_descriptor(const RootSignature* pRootSignature, const char* pResName, uint32_t* pIndex)
{
	GlDescriptorNameToIndexMap::const_iterator it = pRootSignature->pDescriptorNameToIndexMap.find(tinystl::hash(pResName));
	if (it.node)
	{
		*pIndex = it.node->second;
		return &pRootSignature->pDescriptors[it.node->second];
	}
	else
	{
		LOGERRORF("Invalid descriptor param (%s)", pResName);
		return NULL;
	}
}

/************************************************************************/
// Command Buffer Implementation
/************************************************************************/
struct GlCommandList {
	tinystl::vector<GlCmd> mCmds;
};

struct _GlCommandPool {
	tinystl::vector<GlCommandList*>	mCmdLists;
};

/************************************************************************/
// Get renderer shader macros
/************************************************************************/
#define MAX_DYNAMIC_VIEW_DESCRIPTORS_PER_FRAME gGpuDescriptorHeapProperties[0].mMaxDescriptors / 16
#define MAX_DYNAMIC_SAMPLER_DESCRIPTORS_PER_FRAME gGpuDescriptorHeapProperties[1].mMaxDescriptors / 16
/************************************************************************/
// Gloabals
/************************************************************************/
static const uint32_t		gDescriptorTableDWORDS = 1;
static const uint32_t		gRootDescriptorDWORDS = 2;

static volatile uint64_t	gBufferIds	= 0;
static volatile uint64_t	gTextureIds	= 0;
static volatile uint64_t	gSamplerIds	= 0;

static uint32_t				gMaxRootConstantsPerRootParam = 4U;
/************************************************************************/
// Logging functions
/************************************************************************/
// Proxy log callback
static void internal_log(LogType type, const char* msg, const char* component)
{
	switch (type)
	{
	case LOG_TYPE_INFO:
		LOGINFOF("%s ( %s )", component, msg);
		break;
	case LOG_TYPE_WARN:
		LOGWARNINGF("%s ( %s )", component, msg);
		break;
	case LOG_TYPE_DEBUG:
		LOGDEBUGF("%s ( %s )", component, msg);
		break;
	case LOG_TYPE_ERROR:
		LOGERRORF("%s ( %s )", component, msg);
		break;
	default:
		break;
	}
}

//static void add_srv(Renderer* pRenderer, ID3D12Resource* pResource, const OPENGL_SHADER_RESOURCE_VIEW_DESC* pSrvDesc, OPENGL_CPU_DESCRIPTOR_HANDLE* pHandle)
//{
//	*pHandle = add_cpu_descriptor_handles(pRenderer->pCPUDescriptorHeaps[OPENGL_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV], 1);
//	pRenderer->pDxDevice->CreateShaderResourceView(pResource, pSrvDesc, *pHandle);
//}
//
//static void remove_srv(Renderer* pRenderer, OPENGL_CPU_DESCRIPTOR_HANDLE* pHandle)
//{
//	remove_cpu_descriptor_handles(pRenderer->pCPUDescriptorHeaps[OPENGL_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV], pHandle, 1);
//}
//
//static void add_uav(Renderer* pRenderer, ID3D12Resource* pResource, ID3D12Resource* pCounterResource, const OPENGL_UNORDERED_ACCESS_VIEW_DESC* pUavDesc, OPENGL_CPU_DESCRIPTOR_HANDLE* pHandle)
//{
//	*pHandle = add_cpu_descriptor_handles(pRenderer->pCPUDescriptorHeaps[OPENGL_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV], 1);
//	pRenderer->pDxDevice->CreateUnorderedAccessView(pResource, pCounterResource, pUavDesc, *pHandle);
//}
//
//static void remove_uav(Renderer* pRenderer, OPENGL_CPU_DESCRIPTOR_HANDLE* pHandle)
//{
//	remove_cpu_descriptor_handles(pRenderer->pCPUDescriptorHeaps[OPENGL_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV], pHandle, 1);
//}
//
//static void add_cbv(Renderer* pRenderer, const OPENGL_CONSTANT_BUFFER_VIEW_DESC* pCbvDesc, OPENGL_CPU_DESCRIPTOR_HANDLE* pHandle)
//{
//	*pHandle = add_cpu_descriptor_handles(pRenderer->pCPUDescriptorHeaps[OPENGL_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV], 1);
//	pRenderer->pDxDevice->CreateConstantBufferView(pCbvDesc, *pHandle);
//}
//
//static void remove_cbv(Renderer* pRenderer, OPENGL_CPU_DESCRIPTOR_HANDLE* pHandle)
//{
//	remove_cpu_descriptor_handles(pRenderer->pCPUDescriptorHeaps[OPENGL_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV], pHandle, 1);
//}
//
//static void add_rtv(Renderer* pRenderer, ID3D12Resource* pResource, const OPENGL_RENDER_TARGET_VIEW_DESC* pRtvDesc, OPENGL_CPU_DESCRIPTOR_HANDLE* pHandle)
//{
//	*pHandle = add_cpu_descriptor_handles(pRenderer->pCPUDescriptorHeaps[OPENGL_DESCRIPTOR_HEAP_TYPE_RTV], 1);
//	pRenderer->pDxDevice->CreateRenderTargetView(pResource, pRtvDesc, *pHandle);
//}
//
//static void remove_rtv(Renderer* pRenderer, OPENGL_CPU_DESCRIPTOR_HANDLE* pHandle)
//{
//	remove_cpu_descriptor_handles(pRenderer->pCPUDescriptorHeaps[OPENGL_DESCRIPTOR_HEAP_TYPE_RTV], pHandle, 1);
//}
//
//static void add_dsv(Renderer* pRenderer, ID3D12Resource* pResource, const OPENGL_DEPTH_STENCIL_VIEW_DESC* pDsvDesc, OPENGL_CPU_DESCRIPTOR_HANDLE* pHandle)
//{
//	*pHandle = add_cpu_descriptor_handles(pRenderer->pCPUDescriptorHeaps[OPENGL_DESCRIPTOR_HEAP_TYPE_DSV], 1);
//	pRenderer->pDxDevice->CreateDepthStencilView(pResource, pDsvDesc, *pHandle);
//}
//
//static void remove_dsv(Renderer* pRenderer, OPENGL_CPU_DESCRIPTOR_HANDLE* pHandle)
//{
//	remove_cpu_descriptor_handles(pRenderer->pCPUDescriptorHeaps[OPENGL_DESCRIPTOR_HEAP_TYPE_DSV], pHandle, 1);
//}
//
//static void add_sampler(Renderer* pRenderer, const OPENGL_SAMPLER_DESC* pSamplerDesc, OPENGL_CPU_DESCRIPTOR_HANDLE* pHandle)
//{
//	*pHandle = add_cpu_descriptor_handles(pRenderer->pCPUDescriptorHeaps[OPENGL_DESCRIPTOR_HEAP_TYPE::OPENGL_DESCRIPTOR_HEAP_TYPE_SAMPLER], 1);
//	pRenderer->pDxDevice->CreateSampler(pSamplerDesc, *pHandle);
//}
//
//static void remove_sampler(Renderer* pRenderer, OPENGL_CPU_DESCRIPTOR_HANDLE* pHandle)
//{
//	remove_cpu_descriptor_handles(pRenderer->pCPUDescriptorHeaps[OPENGL_DESCRIPTOR_HEAP_TYPE_SAMPLER], pHandle, 1);
//}

static void create_default_resources(Renderer* pRenderer)
{
	//OPENGL_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
	//srvDesc.Format = GL_R8_UINT;
	//srvDesc.ViewDimension = OPENGL_SRV_DIMENSION_TEXTURE1D;
	//srvDesc.Shader4ComponentMapping = OPENGL_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	//
	//OPENGL_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
	//uavDesc.Format = GL_R8_UINT;
	//uavDesc.ViewDimension = OPENGL_UAV_DIMENSION_TEXTURE1D;
	//
	//OPENGL_SAMPLER_DESC samplerDesc = {};
	//samplerDesc.AddressU = samplerDesc.AddressV = samplerDesc.AddressW = OPENGL_TEXTURE_ADDRESS_MODE_BORDER;
	//
	//// Create NULL descriptors in case user does not specify some descriptors we can bind null descriptor handles at those points
	//add_srv(pRenderer, NULL, &srvDesc, &pRenderer->mSrvNullDescriptor);
	//add_uav(pRenderer, NULL, NULL, &uavDesc, &pRenderer->mUavNullDescriptor);
	//add_cbv(pRenderer, NULL, &pRenderer->mCbvNullDescriptor);
	//add_sampler(pRenderer, &samplerDesc, &pRenderer->mSamplerNullDescriptor);

	BlendStateDesc blendStateDesc = {};
	blendStateDesc.mDstAlphaFactor = BC_ZERO;
	blendStateDesc.mDstFactor = BC_ZERO;
	blendStateDesc.mSrcAlphaFactor = BC_ONE;
	blendStateDesc.mSrcFactor = BC_ONE;
	blendStateDesc.mMask = ALL;
	blendStateDesc.mRenderTargetMask = BLEND_STATE_TARGET_ALL;
	addBlendState(pRenderer, &blendStateDesc, &pRenderer->pDefaultBlendState);

	DepthStateDesc depthStateDesc = {};
	depthStateDesc.mDepthFunc = CMP_LEQUAL;
	depthStateDesc.mDepthTest = false;
	depthStateDesc.mDepthWrite = false;
	depthStateDesc.mStencilBackFunc = CMP_ALWAYS;
	depthStateDesc.mStencilFrontFunc = CMP_ALWAYS;
	depthStateDesc.mStencilReadMask = 0xFF;
	depthStateDesc.mStencilWriteMask = 0xFF;
	addDepthState(pRenderer, &depthStateDesc, &pRenderer->pDefaultDepthState);

	RasterizerStateDesc rasterizerStateDesc = {};
	rasterizerStateDesc.mCullMode = CULL_MODE_BACK;
	addRasterizerState(pRenderer, &rasterizerStateDesc, &pRenderer->pDefaultRasterizerState);
}

static void destroy_default_resources(Renderer* pRenderer)
{
	//remove_srv(pRenderer, &pRenderer->mSrvNullDescriptor);
	//remove_uav(pRenderer, &pRenderer->mUavNullDescriptor);
	//remove_cbv(pRenderer, &pRenderer->mCbvNullDescriptor);
	//remove_sampler(pRenderer, &pRenderer->mSamplerNullDescriptor);

	removeBlendState(pRenderer->pDefaultBlendState);
	removeDepthState(pRenderer->pDefaultDepthState);
	removeRasterizerState(pRenderer->pDefaultRasterizerState);
}

typedef enum GpuVendor
{
	GPU_VENDOR_NVIDIA,
	GPU_VENDOR_AMD,
	GPU_VENDOR_INTEL,
	GPU_VENDOR_UNKNOWN,
	GPU_VENDOR_COUNT,
} GpuVendor;

static uint32_t gRootSignatureDWORDS[GpuVendor::GPU_VENDOR_COUNT] = {
	64U,
	13U,
	64U,
	64U,
};

#define VENDOR_ID_NVIDIA 0x10DE
#define VENDOR_ID_AMD 0x1002
#define VENDOR_ID_AMD_1 0x1022
#define VENDOR_ID_INTEL 0x163C
#define VENDOR_ID_INTEL_1 0x8086
#define VENDOR_ID_INTEL_2 0x8087

static GpuVendor util_to_internal_gpu_vendor(UINT vendorId)
{
	if (vendorId == VENDOR_ID_NVIDIA)
		return GPU_VENDOR_NVIDIA;
	else if (vendorId == VENDOR_ID_AMD || vendorId == VENDOR_ID_AMD_1)
		return GPU_VENDOR_AMD;
	else if (vendorId == VENDOR_ID_INTEL || vendorId == VENDOR_ID_INTEL_1 || vendorId == VENDOR_ID_INTEL_2)
		return GPU_VENDOR_INTEL;
	else
		return GPU_VENDOR_UNKNOWN;
}
/************************************************************************/
// Internal utility functions
/************************************************************************/

GLint util_to_gl_primitive_topology_type(PrimitiveTopology topology)
{
	switch (topology)
	{
	case PRIMITIVE_TOPO_POINT_LIST: return GL_POINTS;
	case PRIMITIVE_TOPO_LINE_LIST: return GL_LINES;
	case PRIMITIVE_TOPO_LINE_STRIP: return GL_LINE_STRIP;
	case PRIMITIVE_TOPO_TRI_LIST: return GL_TRIANGLES;
	case PRIMITIVE_TOPO_TRI_STRIP: return GL_TRIANGLE_STRIP;
	case PRIMITIVE_TOPO_PATCH_LIST: return GL_PATCHES;
	}
	return GL_UNKNOWN;
}

//	uint64_t util_gl_determine_storage_counter_offset(uint64_t buffer_size)
//	{
//		uint64_t alignment = OPENGL_UAV_COUNTER_PLACEMENT_ALIGNMENT;
//		uint64_t result = (buffer_size + (alignment - 1)) & ~(alignment - 1);
//		return result;
//	}
//
//	GLint util_to_gl_uav_format(GLint defaultFormat)
//	{
//		switch (defaultFormat)
//		{
//		case GL_R8G8B8A8_TYPELESS:
//		case GL_R8G8B8A8_UNORM:
//		case GL_R8G8B8A8_UNORM_SRGB:
//			return GL_R8G8B8A8_UNORM;
//
//		case GL_B8G8R8A8_TYPELESS:
//		case GL_B8G8R8A8_UNORM:
//		case GL_B8G8R8A8_UNORM_SRGB:
//			return GL_B8G8R8A8_UNORM;
//
//		case GL_B8G8R8X8_TYPELESS:
//		case GL_B8G8R8X8_UNORM:
//		case GL_B8G8R8X8_UNORM_SRGB:
//			return GL_B8G8R8X8_UNORM;
//
//		case GL_R32_TYPELESS:
//		case GL_R32_FLOAT:
//			return GL_R32_FLOAT;
//
//#ifdef _DEBUG
//		case GL_R32G8X24_TYPELESS:
//		case GL_D32_FLOAT_S8X24_UINT:
//		case GL_R32_FLOAT_X8X24_TYPELESS:
//		case GL_X32_TYPELESS_G8X24_UINT:
//		case GL_D32_FLOAT:
//		case GL_R24G8_TYPELESS:
//		case GL_D24_UNORM_S8_UINT:
//		case GL_R24_UNORM_X8_TYPELESS:
//		case GL_X24_TYPELESS_G8_UINT:
//		case GL_D16_UNORM:
//
//			ErrorMsg("Requested a UAV format for a depth stencil format");
//#endif
//
//		default:
//			return defaultFormat;
//		}
//	}
//
//	GLint util_to_gl_dsv_format(GLint defaultFormat)
//	{
//		switch (defaultFormat)
//		{
//			// 32-bit Z w/ Stencil
//		case GL_R32G8X24_TYPELESS:
//		case GL_D32_FLOAT_S8X24_UINT:
//		case GL_R32_FLOAT_X8X24_TYPELESS:
//		case GL_X32_TYPELESS_G8X24_UINT:
//			return GL_D32_FLOAT_S8X24_UINT;
//
//			// No Stencil
//		case GL_R32_TYPELESS:
//		case GL_D32_FLOAT:
//		case GL_R32_FLOAT:
//			return GL_D32_FLOAT;
//
//			// 24-bit Z
//		case GL_R24G8_TYPELESS:
//		case GL_D24_UNORM_S8_UINT:
//		case GL_R24_UNORM_X8_TYPELESS:
//		case GL_X24_TYPELESS_G8_UINT:
//			return GL_D24_UNORM_S8_UINT;
//
//			// 16-bit Z w/o Stencil
//		case GL_R16_TYPELESS:
//		case GL_D16_UNORM:
//		case GL_R16_UNORM:
//			return GL_D16_UNORM;
//
//		default:
//			return defaultFormat;
//		}
//	}
//
//	GLint util_to_gl_srv_format(GLint defaultFormat)
//	{
//		switch (defaultFormat)
//		{
//			// 32-bit Z w/ Stencil
//		case GL_R32G8X24_TYPELESS:
//		case GL_D32_FLOAT_S8X24_UINT:
//		case GL_R32_FLOAT_X8X24_TYPELESS:
//		case GL_X32_TYPELESS_G8X24_UINT:
//			return GL_R32_FLOAT_X8X24_TYPELESS;
//
//			// No Stencil
//		case GL_R32_TYPELESS:
//		case GL_D32_FLOAT:
//		case GL_R32_FLOAT:
//			return GL_R32_FLOAT;
//
//			// 24-bit Z
//		case GL_R24G8_TYPELESS:
//		case GL_D24_UNORM_S8_UINT:
//		case GL_R24_UNORM_X8_TYPELESS:
//		case GL_X24_TYPELESS_G8_UINT:
//			return GL_R24_UNORM_X8_TYPELESS;
//
//			// 16-bit Z w/o Stencil
//		case GL_R16_TYPELESS:
//		case GL_D16_UNORM:
//		case GL_R16_UNORM:
//			return GL_R16_UNORM;
//
//		case GL_R8G8B8A8_TYPELESS:
//			return GL_R8G8B8A8_UNORM;
//
//		default:
//			return defaultFormat;
//		}
//	}
//
//	GLint util_to_gl_stencil_format(GLint defaultFormat)
//	{
//		switch (defaultFormat)
//		{
//			// 32-bit Z w/ Stencil
//		case GL_R32G8X24_TYPELESS:
//		case GL_D32_FLOAT_S8X24_UINT:
//		case GL_R32_FLOAT_X8X24_TYPELESS:
//		case GL_X32_TYPELESS_G8X24_UINT:
//			return GL_X32_TYPELESS_G8X24_UINT;
//
//			// 24-bit Z
//		case GL_R24G8_TYPELESS:
//		case GL_D24_UNORM_S8_UINT:
//		case GL_R24_UNORM_X8_TYPELESS:
//		case GL_X24_TYPELESS_G8_UINT:
//			return GL_X24_TYPELESS_G8_UINT;
//
//		default:
//			return GL_UNKNOWN;
//		}
//	}
//
//	GLint util_to_gl_swapchain_format(ImageFormat::Enum format)
//	{
//		GLint result = GL_UNKNOWN;
//
//		// FLIP_DISCARD and FLIP_SEQEUNTIAL swapchain buffers only support these formats
//		switch (format)
//		{
//		case ImageFormat::RGBA16F:
//			result = GL_R16G16B16A16_FLOAT;
//		case ImageFormat::BGRA8:
//			result = GL_B8G8R8A8_UNORM;
//			break;
//		case ImageFormat::RGBA8:
//			result = GL_R8G8B8A8_UNORM;
//			break;
//		case ImageFormat::RGB10A2:
//			result = GL_R10G10B10A2_UNORM;
//			break;
//		default:
//			break;
//		}
//
//		if (result == GL_UNKNOWN)
//		{
//			LOGERRORF("Image Format (%u) not supported for creating swapchain buffer", (uint32_t)format);
//		}
//
//		return result;
//	}

GLenum util_to_gl_shader_type(ShaderStage stage)
{
	switch (stage)
	{
	case SHADER_STAGE_VERT: return GL_VERTEX_SHADER;
	case SHADER_STAGE_TESC: return GL_TESS_CONTROL_SHADER;
	case SHADER_STAGE_TESE: return GL_TESS_EVALUATION_SHADER;
	case SHADER_STAGE_GEOM: return GL_GEOMETRY_SHADER;
	case SHADER_STAGE_FRAG: return GL_FRAGMENT_SHADER;
	case SHADER_STAGE_COMP: return GL_COMPUTE_SHADER;
	}
	return GL_UNKNOWN;
}

//	OPENGL_SHADER_VISIBILITY util_to_gl_shader_visibility(ShaderStage stages)
//	{
//		OPENGL_SHADER_VISIBILITY res = OPENGL_SHADER_VISIBILITY_ALL;
//		uint32_t stageCount = 0;
//
//		if (stages & SHADER_STAGE_COMP)
//		{
//			return OPENGL_SHADER_VISIBILITY_ALL;
//		}
//		if (stages & SHADER_STAGE_VERT)
//		{
//			res = OPENGL_SHADER_VISIBILITY_VERTEX;
//			++stageCount;
//		}
//		if (stages & SHADER_STAGE_GEOM)
//		{
//			res = OPENGL_SHADER_VISIBILITY_GEOMETRY;
//			++stageCount;
//		}
//		if (stages & SHADER_STAGE_HULL)
//		{
//			res = OPENGL_SHADER_VISIBILITY_HULL;
//			++stageCount;
//		}
//		if (stages & SHADER_STAGE_DOMN)
//		{
//			res = OPENGL_SHADER_VISIBILITY_DOMAIN;
//			++stageCount;
//		}
//		if (stages & SHADER_STAGE_FRAG)
//		{
//			res = OPENGL_SHADER_VISIBILITY_PIXEL;
//			++stageCount;
//		}
//		ASSERT(stageCount > 0);
//		return stageCount > 1 ? OPENGL_SHADER_VISIBILITY_ALL : res;
//	}

//	OPENGL_DESCRIPTOR_RANGE_TYPE util_to_gl_descriptor_range(DescriptorType type)
//	{
//		switch (type)
//		{
//		case DESCRIPTOR_TYPE_UNIFORM_BUFFER:
//			return OPENGL_DESCRIPTOR_RANGE_TYPE_CBV;
//		case DESCRIPTOR_TYPE_TEXTURE:
//		case DESCRIPTOR_TYPE_BUFFER:
//			return OPENGL_DESCRIPTOR_RANGE_TYPE_SRV;
//		case DESCRIPTOR_TYPE_RW_BUFFER:
//		case DESCRIPTOR_TYPE_RW_TEXTURE:
//			return OPENGL_DESCRIPTOR_RANGE_TYPE_UAV;
//		case DESCRIPTOR_TYPE_SAMPLER:
//			return OPENGL_DESCRIPTOR_RANGE_TYPE_SAMPLER;
//		default:
//			ASSERT("Invalid DescriptorInfo Type");
//			return (OPENGL_DESCRIPTOR_RANGE_TYPE)-1;
//		}
//	}

//	OPENGL_RESOURCE_STATES util_to_gl_resource_state(ResourceState state)
//	{
//		OPENGL_RESOURCE_STATES ret = (OPENGL_RESOURCE_STATES)state;
//
//		// These states cannot be combined with other states so we just do an == check
//		if (state == RESOURCE_STATE_GENERIC_READ)
//			return OPENGL_RESOURCE_STATE_GENERIC_READ;
//		if (state == RESOURCE_STATE_COMMON)
//			return OPENGL_RESOURCE_STATE_COMMON;
//		if (state == RESOURCE_STATE_PRESENT)
//			return OPENGL_RESOURCE_STATE_PRESENT;
//
//		if (state & RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER)
//			ret |= OPENGL_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER;
//		if (state & RESOURCE_STATE_INDEX_BUFFER)
//			ret |= OPENGL_RESOURCE_STATE_INDEX_BUFFER;
//		if (state & RESOURCE_STATE_RENDER_TARGET)
//			ret |= OPENGL_RESOURCE_STATE_RENDER_TARGET;
//		if (state & RESOURCE_STATE_UNORDERED_ACCESS)
//			ret |= OPENGL_RESOURCE_STATE_UNORDERED_ACCESS;
//		if (state & RESOURCE_STATE_DEPTH_WRITE)
//			ret |= OPENGL_RESOURCE_STATE_DEPTH_WRITE;
//		if (state & RESOURCE_STATE_DEPTH_READ)
//			ret |= OPENGL_RESOURCE_STATE_DEPTH_READ;
//		if (state & RESOURCE_STATE_STREAM_OUT)
//			ret |= OPENGL_RESOURCE_STATE_STREAM_OUT;
//		if (state & RESOURCE_STATE_INDIRECT_ARGUMENT)
//			ret |= OPENGL_RESOURCE_STATE_INDIRECT_ARGUMENT;
//		if (state & RESOURCE_STATE_COPY_DEST)
//			ret |= OPENGL_RESOURCE_STATE_COPY_DEST;
//		if (state & RESOURCE_STATE_COPY_SOURCE)
//			ret |= OPENGL_RESOURCE_STATE_COPY_SOURCE;
//
//		if (state == RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
//			ret |= OPENGL_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
//		else if (state & RESOURCE_STATE_SHADER_RESOURCE)
//			ret |= (OPENGL_RESOURCE_STATE_PIXEL_SHADER_RESOURCE | OPENGL_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE);
//
//		return ret;
//	}

//	OPENGL_QUERY_HEAP_TYPE util_to_gl_query_heap_type(QueryType type)
//	{
//		switch (type)
//		{
//		case QUERY_TYPE_TIMESTAMP:
//			return OPENGL_QUERY_HEAP_TYPE_TIMESTAMP;
//		case QUERY_TYPE_PIPELINE_STATISTICS:
//			return OPENGL_QUERY_HEAP_TYPE_PIPELINE_STATISTICS;
//		case QUERY_TYPE_OCCLUSION:
//			return OPENGL_QUERY_HEAP_TYPE_OCCLUSION;
//		default:
//			ASSERT(false && "Invalid query heap type");
//			return OPENGL_QUERY_HEAP_TYPE(-1);
//		}
//	}

//	OPENGL_QUERY_TYPE util_to_gl_query_type(QueryType type)
//	{
//		switch (type)
//		{
//		case QUERY_TYPE_TIMESTAMP:
//			return OPENGL_QUERY_TYPE_TIMESTAMP;
//		case QUERY_TYPE_PIPELINE_STATISTICS:
//			return OPENGL_QUERY_TYPE_PIPELINE_STATISTICS;
//		case QUERY_TYPE_OCCLUSION:
//			return OPENGL_QUERY_TYPE_OCCLUSION;
//		default:
//			ASSERT(false && "Invalid query heap type");
//			return OPENGL_QUERY_TYPE(-1);
//		}
//	}
static GLint util_to_gl_texture_internal_format(ImageFormat::Enum format)
{
	GLint result = GL_UNKNOWN;
	if (format >= sizeof(gGLTexImageInternalFormatTranslator) / sizeof(GLint)) {
		LOGERRORF("Failed to Map from ConfettilFileFromat to DXGI format, should add map method in gGLFormatTranslator");
	}
	else {
		result = gGLTexImageInternalFormatTranslator[format];
	}

	return result;
}

static GLenum util_to_gl_texture_format(ImageFormat::Enum format)
{
	GLenum result = GL_UNKNOWN;
	if (format >= sizeof(gGLTexImageFormatTranslator) / sizeof(GLint)) {
		LOGERRORF("Failed to Map from ConfettilFileFromat to DXGI format, should add map method in gGLFormatTranslator");
	}
	else {
		result = gGLTexImageFormatTranslator[format];
	}

	return result;
}

static GLenum util_to_gl_texture_type(ImageFormat::Enum format)
{
	GLenum result = GL_UNKNOWN;
	if (format >= sizeof(gGLTexImageTypeTranslator) / sizeof(GLint)) {
		LOGERRORF("Failed to Map from ConfettilFileFromat to DXGI format, should add map method in gGLFormatTranslator");
	}
	else {
		result = gGLTexImageTypeTranslator[format];
	}

	return result;
}

static const GLint gGLTextureFilterTranslator[] =
{
	GL_NEAREST,
	GL_LINEAR,
	GL_NEAREST_MIPMAP_NEAREST,
	GL_LINEAR_MIPMAP_NEAREST,
	GL_NEAREST_MIPMAP_LINEAR,
	GL_LINEAR_MIPMAP_LINEAR,
	GL_EXT_texture_filter_anisotropic
};
static GLint util_to_gl_texture_filter(FilterType filter)
{
	return gGLTextureFilterTranslator[filter];
}

static const GLint gGLTextureWrapTranslator[] =
{
	GL_MIRRORED_REPEAT,
	GL_REPEAT,
	GL_CLAMP_TO_EDGE,
	GL_CLAMP_TO_BORDER
};
static GLint util_to_gl_texture_wrap(AddressMode addressMode)
{
	return gGLTextureWrapTranslator[addressMode];
}

static const GLint gGLTextureCompareModeTranslator[] =
{
	GL_NONE,
	GL_COMPARE_REF_TO_TEXTURE,
	GL_COMPARE_REF_TO_TEXTURE,
	GL_COMPARE_REF_TO_TEXTURE,
	GL_COMPARE_REF_TO_TEXTURE,
	GL_COMPARE_REF_TO_TEXTURE,
	GL_COMPARE_REF_TO_TEXTURE,
	GL_COMPARE_REF_TO_TEXTURE
};
static GLint util_to_gl_texture_compare_mode(CompareMode compareMode)
{
	return gGLTextureCompareModeTranslator[compareMode];
}

static const GLint gGLTextureCompareFuncTranslator[] =
{
	GL_NEVER,
	GL_LESS,
	GL_EQUAL,
	GL_LEQUAL,
	GL_GREATER,
	GL_NOTEQUAL,
	GL_GEQUAL,
	GL_ALWAYS
};
static GLint util_to_gl_texture_compare_func(CompareMode compareMode)
{
	return gGLTextureCompareFuncTranslator[compareMode];
}

static void queueSignal(Queue* pQueue, Fence* pFence)
{
	UNREF_PARAM(pQueue);

	pFence->mGlSync = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);

	pFence->mSubmitted = true;
}

/************************************************************************/
// Multi GPU Helper Functions
/************************************************************************/
//	uint32_t util_calculate_shared_node_mask(Renderer* pRenderer)
//	{
//		if (pRenderer->mSettings.mGpuMode == GPU_MODE_LINKED)
//			return (1 << pRenderer->mDxLinkedNodeCount) - 1;
//		else
//			return 0;
//	}
//
//	uint32_t util_calculate_node_mask(Renderer* pRenderer, uint32_t i)
//	{
//		if (pRenderer->mSettings.mGpuMode == GPU_MODE_LINKED)
//			return (1 << i);
//		else
//			return 0;
//	}

/************************************************************************/
// Internal init functions
/************************************************************************/
static void addDevice(Renderer* pRenderer)
{
	ASSERT(pRenderer->mSettings.mGpuMode == GPU_MODE_SINGLE);

	pRenderer->mNumOfGPUs = 1;

	pRenderer->pActiveGpuSettings = &pRenderer->mGpuSettings[0];

	//LOGINFOF("Vendor id of selected gpu: %s", pRenderer->pActiveGpuSettings->mGpuVendorPreset.mVendorId.c_str());
	//LOGINFOF("Model id of selected gpu: %s", pRenderer->pActiveGpuSettings->mGpuVendorPreset.mModelId.c_str());
}

static void initDevice(Renderer* pRenderer)
{
	for (uint32_t i = 0; i < pRenderer->mNumOfGPUs; ++i)
	{
		GLint minUniformBufferOffsetAlignment;
		glGetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, &minUniformBufferOffsetAlignment);

		pRenderer->mGpuSettings[i].mUniformBufferAlignment = minUniformBufferOffsetAlignment;
		//pRenderer->mGpuSettings[i].mMaxVertexInputBindings = pRenderer->mVkGpuProperties[i].limits.maxVertexInputBindings;
		//pRenderer->mGpuSettings[i].mMultiDrawIndirect = pRenderer->mVkGpuProperties[i].limits.maxDrawIndirectCount > 1;
		//
		////save vendor and model Id as string
		//char hexChar[10];
		//sprintf(hexChar, "%#x", pRenderer->mVkGpuProperties[i].deviceID);
		//pRenderer->mGpuSettings[i].mGpuVendorPreset.mModelId = String(hexChar);
		//sprintf(hexChar, "%#x", pRenderer->mVkGpuProperties[i].vendorID);
		//pRenderer->mGpuSettings[i].mGpuVendorPreset.mVendorId = String(hexChar);
		//pRenderer->mGpuSettings[i].mGpuVendorPreset.mPresetLevel = GPUPresetLevel::GPU_PRESET_LOW;
	}
}

static void removeDevice(Renderer* pRenderer)
{
}

#if defined(__cplusplus) && defined(ENABLE_RENDERER_RUNTIME_SWITCH)
namespace opengl {
#endif

	/************************************************************************/
	// Functions not exposed in IRenderer but still need to be exported in dll
	/************************************************************************/
	API_INTERFACE void CALLTYPE addBuffer(Renderer* pRenderer, const BufferDesc* pDesc, Buffer** pp_buffer);
	API_INTERFACE void CALLTYPE removeBuffer(Renderer* pRenderer, Buffer* pBuffer);
	API_INTERFACE void CALLTYPE addTexture(Renderer* pRenderer, const TextureDesc* pDesc, Texture** ppTexture);
	API_INTERFACE void CALLTYPE removeTexture(Renderer* pRenderer, Texture* pTexture);
	API_INTERFACE void CALLTYPE mapBuffer(Renderer* pRenderer, Buffer* pBuffer, ReadRange* pRange);
	API_INTERFACE void CALLTYPE unmapBuffer(Renderer* pRenderer, Buffer* pBuffer);
	API_INTERFACE void CALLTYPE cmdUpdateBuffer(Cmd* pCmd, uint64_t srcOffset, uint64_t dstOffset, uint64_t size, Buffer* pSrcBuffer, Buffer* pBuffer);
	API_INTERFACE void CALLTYPE cmdUpdateSubresources(Cmd* pCmd, uint32_t startSubresource, uint32_t numSubresources, SubresourceDataDesc* pSubresources, Buffer* pIntermediate, uint64_t intermediateOffset, Texture* pTexture);
	API_INTERFACE void CALLTYPE compileShader(Renderer* pRenderer, ShaderStage stage, const char* fileName, uint32_t codeSize, const char* code, uint32_t macroCount, ShaderMacro* pMacros, void*(*allocator)(size_t a), uint32_t* pByteCodeSize, char** ppByteCode);
	API_INTERFACE const RendererShaderDefinesDesc CALLTYPE get_renderer_shaderdefines(Renderer* pRenderer);
	/************************************************************************/
	// Renderer Init Remove
	/************************************************************************/
	void initRenderer(const char* appName, const RendererDesc* settings, Renderer** ppRenderer)
	{
		Renderer* pRenderer = (Renderer*)conf_calloc(1, sizeof(*pRenderer));

		pRenderer->pName = (char*)conf_calloc(strlen(appName) + 1, sizeof(char));
		memcpy(pRenderer->pName, appName, strlen(appName));

		memcpy(&(pRenderer->mSettings), settings, sizeof(RendererDesc));

		pRenderer->mSettings.mApi = RENDERER_API_OPENGL;

		// Initialize the OpenGL OS bits with GLFW
		if (!glfwInit())
		{
			LOGERRORF("Failed to init GLFW library");
		}

		// Require OpenGL 4.5
		int contextVersionMajor = 4;
		int contextVersionMinor = 5;
		glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, contextVersionMajor);
		glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, contextVersionMinor);
		glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

		// Abstract the OpenGL context as a SwapChain
		addSwapChain(pRenderer, &pRenderer->mSettings.mSwapChainDesc, &pRenderer->pSwapChain);

		// Initialize the OpenGL PFN with GLEW
		glewExperimental = GL_TRUE;
		if (glewInit())
		{
			LOGERRORF("Failed to init GLEW library");
		}

		if (!GLEW_ARB_gl_spirv)
		{
			LOGERRORF("Engine requires support for SPIR-V (GL_ARB_gl_spirv)!");
		}

#ifdef _DEBUG
        glEnable(GL_DEBUG_OUTPUT);
        glDebugMessageCallback(MessageCallback, 0);
#endif

		pRenderer->pGlContext = NULL;
		pRenderer->pGlContextState = (GlContextState*)conf_calloc(1, sizeof(*pRenderer->pGlContextState));

		// Renderer is good! Assign it to result!
		*(ppRenderer) = pRenderer;
	}

	void removeRenderer(Renderer* pRenderer)
	{
        ASSERT(pRenderer);

        removeDevice(pRenderer);

        // Terminate GLFW
        glfwTerminate();

		SAFE_FREE(pRenderer->pGlContextState);
		SAFE_FREE(pRenderer);
    }
	/************************************************************************/
	// Resource Creation Functions
	/************************************************************************/
	void addFence(Renderer* pRenderer, Fence** ppFence)
	{
		ASSERT(pRenderer);

		Fence* pFence = (Fence*)conf_calloc(1, sizeof(*pFence));
		ASSERT(pFence);

		*ppFence = pFence;
	}

	void removeFence(Renderer* pRenderer, Fence* pFence)
	{
		ASSERT(pRenderer);
		ASSERT(pFence);

		SAFE_FREE(pFence);
	}

	void addSemaphore(Renderer* pRenderer, Semaphore** ppSemaphore)
	{
		ASSERT(pRenderer);

		Semaphore* pSemaphore = (Semaphore*)conf_calloc(1, sizeof(*pSemaphore));
		ASSERT(pSemaphore);

		*ppSemaphore = pSemaphore;
	}

	void removeSemaphore(Renderer* pRenderer, Semaphore* pSemaphore)
	{
		ASSERT(pRenderer);
		ASSERT(pSemaphore);

		SAFE_FREE(pSemaphore);
	}

	void addQueue(Renderer* pRenderer, QueueDesc* pQDesc, Queue** ppQueue)
	{
		Queue* pQueue = (Queue*)conf_calloc(1, sizeof(*pQueue));

		pQueue->pRenderer = pRenderer;

		*ppQueue = pQueue;
	}

	void removeQueue(Queue* pQueue)
	{
		ASSERT(pQueue);

		SAFE_FREE(pQueue);
	}

	void addCmdPool(Renderer *pRenderer, Queue* pQueue, bool transient, CmdPool** ppCmdPool)
	{
		ASSERT(pRenderer);

		CmdPool* pCmdPool = (CmdPool*)conf_calloc(1, sizeof(*pCmdPool));
		ASSERT(pCmdPool);

		pCmdPool->mCmdPoolDesc = { pQueue->mQueueDesc.mType };
		pCmdPool->pQueue = pQueue;

		*ppCmdPool = pCmdPool;
	}

	void removeCmdPool(Renderer *pRenderer, CmdPool* pCmdPool)
	{
		ASSERT(pRenderer);
		ASSERT(pCmdPool);

		SAFE_FREE(pCmdPool);
	}

	void addCmd(CmdPool* pCmdPool, bool secondary, Cmd** ppCmd)
	{
		ASSERT(pCmdPool);

		Cmd* pCmd = (Cmd*)conf_calloc(1, sizeof(*pCmd));
		ASSERT(pCmd);

		//set command pool of new command
		pCmd->pRenderer = pCmdPool->pQueue->pRenderer;
		pCmd->pCmdPool = pCmdPool;

		pCmd->pGlCmdList = (GlCommandList*)conf_calloc(1, sizeof(GlCommandList));

		*ppCmd = pCmd;
	}

	void removeCmd(CmdPool* pCmdPool, Cmd* pCmd)
	{
		ASSERT(pCmdPool);
		ASSERT(pCmd);

		SAFE_FREE(pCmd->pGlCmdList);

		SAFE_FREE(pCmd);
	}

	void addCmd_n(CmdPool *pCmdPool, bool secondary, uint32_t cmdCount, Cmd*** pppCmd)
	{
		ASSERT(pppCmd);

		Cmd** ppCmd = (Cmd**)conf_calloc(cmdCount, sizeof(*ppCmd));

		for (uint32_t i = 0; i < cmdCount; ++i) {
			::addCmd(pCmdPool, secondary, &(ppCmd[i]));
		}

		*pppCmd = ppCmd;
	}

	void removeCmd_n(CmdPool *pCmdPool, uint32_t cmdCount, Cmd** ppCmd)
	{
		ASSERT(ppCmd);

		for (uint32_t i = 0; i < cmdCount; ++i) {
			::removeCmd(pCmdPool, ppCmd[i]);
		}

		SAFE_FREE(ppCmd);
	}

	void addSwapChain(Renderer* pRenderer, const SwapChainDesc* pDesc, SwapChain** ppSwapChain)
	{
		ASSERT(pRenderer);
		ASSERT(pDesc);
		ASSERT(ppSwapChain);

		SwapChain* pSwapChain = (SwapChain*)conf_calloc(1, sizeof(SwapChain));
		pSwapChain->mDesc = *pDesc;

		// Image count
		if (1 == pSwapChain->mDesc.mImageCount)
		{
			glfwWindowHint(GLFW_DOUBLEBUFFER, 0);
		}
		else
		{
			glfwWindowHint(GLFW_DOUBLEBUFFER, 1);
		}

		glfwWindowHint(GLFW_SAMPLES, (int)pSwapChain->mDesc.mSampleCount);
		glfwWindowHint(GLFW_SRGB_CAPABLE, pSwapChain->mDesc.mSrgb);

		addDevice(pRenderer);

		// TODO: context sharing
		// HACK: create a GLFWwindow by hand
		_GLFWwindow* pWindow = (_GLFWwindow*)conf_calloc(1, sizeof(_GLFWwindow));
		pWindow->win32.handle = (HWND)pSwapChain->mDesc.pWindow->handle;

		glfwCreateContext((GLFWwindow*)pWindow);

		glfwMakeContextCurrent((GLFWwindow*)pWindow);

		// framebuffer size
		GLint viewport[4];
		glGetIntegerv(GL_VIEWPORT, &viewport[0]);

		// OpenGL device information retrieval requires a valid context first.
		initDevice(pRenderer);

		pSwapChain->pContextView = reinterpret_cast<GlContextView>(pWindow);

		RenderTargetDesc descColor = {};
		descColor.mType = RENDER_TARGET_TYPE_2D;
		descColor.mUsage = RENDER_TARGET_USAGE_COLOR;
		descColor.mWidth = viewport[2];
		descColor.mHeight = viewport[3];
		descColor.mDepth = 1;
		descColor.mArraySize = 1;
		descColor.mFormat = pSwapChain->mDesc.mColorFormat;
		descColor.mSrgb = pSwapChain->mDesc.mSrgb;
		descColor.mClearValue = pSwapChain->mDesc.mColorClearValue;
		descColor.mSampleCount = SAMPLE_COUNT_1;
		descColor.mSampleQuality = 0;
		descColor.mDefaultFramebufferOwned = true;

		pSwapChain->ppSwapchainRenderTargets = (RenderTarget**)conf_calloc(pSwapChain->mDesc.mImageCount, sizeof(*pSwapChain->ppSwapchainRenderTargets));

		// Populate the vk_image field and add the Vulkan texture objects
		for (uint32_t i = 0; i < pSwapChain->mDesc.mImageCount; ++i)
		{
			addRenderTarget(pRenderer, &descColor, &pSwapChain->ppSwapchainRenderTargets[i]);
		}

		*ppSwapChain = pSwapChain;
	}

	void removeSwapChain(Renderer* pRenderer, SwapChain* pSwapChain)
	{
		ASSERT(pRenderer);
		ASSERT(pSwapChain);

		for (uint32_t i = 0; i < pSwapChain->mDesc.mImageCount; ++i)
		{
			removeRenderTarget(pRenderer, pSwapChain->ppSwapchainRenderTargets[i]);
		}

		SAFE_FREE(pSwapChain);
	}

	void addBuffer(Renderer* pRenderer, const BufferDesc* pDesc, Buffer** ppBuffer)
	{
		ASSERT(pRenderer);
		ASSERT(pDesc);
		ASSERT(pDesc->mSize > 0);

		Buffer* pBuffer = (Buffer*)conf_calloc(1, sizeof(*pBuffer));
		ASSERT(pBuffer);

		pBuffer->mDesc = *pDesc;

		switch (pBuffer->mDesc.mUsage)
		{
		case BUFFER_USAGE_UPLOAD: {
			glCreateBuffers(1, &pBuffer->mGlRes);

			GLbitfield flags = GL_MAP_WRITE_BIT;
			if (pBuffer->mDesc.mFlags & BUFFER_CREATION_FLAG_PERSISTENT_MAP_BIT)
				flags |= GL_MAP_PERSISTENT_BIT;// | GL_MAP_COHERENT_BIT;
			glNamedBufferStorage(pBuffer->mGlRes, pBuffer->mDesc.mSize, NULL, flags);

			if (pBuffer->mDesc.mFlags & BUFFER_CREATION_FLAG_PERSISTENT_MAP_BIT) {
				flags |= GL_MAP_FLUSH_EXPLICIT_BIT;
				pBuffer->pCpuMappedAddress = glMapNamedBufferRange(pBuffer->mGlRes, 0, pBuffer->mDesc.mSize, flags);
			}
		} break;
		case BUFFER_USAGE_UNIFORM:
		{
			glCreateBuffers(1, &pBuffer->mGlRes);

			GLbitfield flags = GL_MAP_WRITE_BIT;
			if (pBuffer->mDesc.mFlags & BUFFER_CREATION_FLAG_PERSISTENT_MAP_BIT)
				flags |= GL_MAP_PERSISTENT_BIT | GL_MAP_COHERENT_BIT;
			glNamedBufferStorage(pBuffer->mGlRes, pBuffer->mDesc.mSize, NULL, flags);

			if (pBuffer->mDesc.mFlags & BUFFER_CREATION_FLAG_PERSISTENT_MAP_BIT) {
				pBuffer->pCpuMappedAddress = glMapNamedBufferRange(pBuffer->mGlRes, 0, pBuffer->mDesc.mSize, flags);
			}
		} break;
		case BUFFER_USAGE_STORAGE_SRV:
		break;
		case BUFFER_USAGE_STORAGE_UAV:
		break;
		case BUFFER_USAGE_INDEX:
		{
			glCreateBuffers(1, &pBuffer->mGlRes);
			glNamedBufferStorage(pBuffer->mGlRes, pBuffer->mDesc.mSize, NULL, GL_DYNAMIC_STORAGE_BIT);
		} break;
		case BUFFER_USAGE_VERTEX:
		{
			glCreateBuffers(1, &pBuffer->mGlRes);
			glNamedBufferStorage(pBuffer->mGlRes, pBuffer->mDesc.mSize, NULL, GL_DYNAMIC_STORAGE_BIT);
		} break;
		case BUFFER_USAGE_INDIRECT:
		break;
		}

		pBuffer->mBufferId = (++gBufferIds << 8U) + Thread::GetCurrentThreadID();

		*ppBuffer = pBuffer;
	}

	void removeBuffer(Renderer* pRenderer, Buffer* pBuffer)
	{
		ASSERT(pRenderer);
		ASSERT(pBuffer);

		SAFE_FREE(pBuffer);
	}

	GLenum util_to_gl_texture_target(TextureType type)
	{
		switch (type)
		{
		case TEXTURE_TYPE_1D: return GL_TEXTURE_1D;
		case TEXTURE_TYPE_2D: return GL_TEXTURE_2D;
		case TEXTURE_TYPE_3D: return GL_TEXTURE_3D;
		case TEXTURE_TYPE_CUBE: return GL_TEXTURE_CUBE_MAP;
		}
		return GL_UNKNOWN;
	}

	void addTexture(Renderer* pRenderer, const TextureDesc* pDesc, Texture** ppTexture)
	{
		ASSERT(pRenderer);
		ASSERT(pDesc && pDesc->mWidth && pDesc->mHeight && (pDesc->mDepth || pDesc->mArraySize));
		if (pDesc->mSampleCount > SAMPLE_COUNT_1 && pDesc->mMipLevels > 1)
		{
			LOGERROR("Multi-Sampled textures cannot have mip maps");
			ASSERT(false);
			return;
		}

		Texture* pTexture = (Texture*)conf_calloc(1, sizeof(*pTexture));
		ASSERT(pTexture);

		pTexture->mDesc = *pDesc;
		pTexture->mTextureId = (++gTextureIds << 8U) + Thread::GetCurrentThreadID();

		if (pDesc->pNativeHandle)
		{
			pTexture->mOwnsImage = false;
			pTexture->mGlRes = (GLuint)(size_t)pDesc->pNativeHandle;
		}
		else
		{
			pTexture->mOwnsImage = true;
		}

		if (!pTexture->mGlRes)
		{
			glGenTextures(1, &pTexture->mGlRes);
		}

		GLenum target = util_to_gl_texture_target(pDesc->mType);

		switch (target)
		{
		case GL_TEXTURE_2D:
		{
			glBindTexture(GL_TEXTURE_2D, pTexture->mGlRes);

			GLint internalFormat = util_to_gl_texture_internal_format(pDesc->mFormat);
			glTexStorage2D(target, pTexture->mDesc.mMipLevels, internalFormat, pDesc->mWidth, pDesc->mHeight);
		}
		default:
			break;
		}

		// require no texture size, internally managed by OpenGL API
		pTexture->mTextureSize = 0;

		*ppTexture = pTexture;
	}

	void removeTexture(Renderer* pRenderer, Texture* pTexture)
	{
		ASSERT(pRenderer);
		ASSERT(pTexture);

		//glDeleteTextures(1, &pTexture->mGlRes);

		SAFE_FREE(pTexture);
	}

	void addRenderTarget(Renderer* pRenderer, const RenderTargetDesc* pDesc, RenderTarget** ppRenderTarget)
	{
		ASSERT(pRenderer);
		ASSERT(pDesc);
		ASSERT(ppRenderTarget);

		RenderTarget* pRenderTarget = (RenderTarget*)conf_calloc(1, sizeof(*pRenderTarget));
		pRenderTarget->mDesc = *pDesc;

		//::addTexture(pRenderer, &textureDesc, &pRenderTarget->pTexture);

		*ppRenderTarget = pRenderTarget;
	}

	void removeRenderTarget(Renderer* pRenderer, RenderTarget* pRenderTarget)
	{
		//::removeTexture(pRenderer, pRenderTarget->pTexture);

		SAFE_FREE(pRenderTarget);
	}

	void addSampler(Renderer* pRenderer, const SamplerDesc* pDesc, Sampler** ppSampler)
	{
		ASSERT(pRenderer);
		ASSERT(pDesc->mCompareFunc < MAX_COMPARE_MODES);

		Sampler* pSampler = (Sampler*)conf_calloc(1, sizeof(*pSampler));

		pSampler->mDesc = *pDesc;

		glCreateSamplers(1, &pSampler->mGlRes);

		GLint minFilter = util_to_gl_texture_filter(pDesc->mMinFilter);
		GLint maxFilter = util_to_gl_texture_filter(pDesc->mMagFilter);
		GLint wrapS = util_to_gl_texture_wrap(pDesc->mAddressU);
		GLint wrapT = util_to_gl_texture_wrap(pDesc->mAddressV);
		GLint wrapR = util_to_gl_texture_wrap(pDesc->mAddressW);
		GLint compareMode = util_to_gl_texture_compare_mode(pDesc->mCompareFunc);
		GLint compareFunc = util_to_gl_texture_compare_func(pDesc->mCompareFunc);

		glSamplerParameteri(pSampler->mGlRes, GL_TEXTURE_WRAP_S, wrapS);
		glSamplerParameteri(pSampler->mGlRes, GL_TEXTURE_WRAP_T, wrapT);
		glSamplerParameteri(pSampler->mGlRes, GL_TEXTURE_WRAP_R, wrapR);
		glSamplerParameteri(pSampler->mGlRes, GL_TEXTURE_MIN_FILTER, minFilter);
		glSamplerParameteri(pSampler->mGlRes, GL_TEXTURE_MAG_FILTER, maxFilter);
		glSamplerParameteri(pSampler->mGlRes, GL_TEXTURE_COMPARE_MODE, compareMode);
		glSamplerParameteri(pSampler->mGlRes, GL_TEXTURE_COMPARE_FUNC, compareFunc);

		*ppSampler = pSampler;
	}

	void removeSampler(Renderer* pRenderer, Sampler* pSampler)
	{
		ASSERT(pRenderer);

		glDeleteSamplers(1, &pSampler->mGlRes);

		SAFE_FREE(pSampler);
	}
	/************************************************************************/
	// Buffer Functions
	/************************************************************************/
	void mapBuffer(Renderer* pRenderer, Buffer* pBuffer, ReadRange* pRange)
	{
		ASSERT(pRenderer);

		pBuffer->pCpuMappedAddress = glMapNamedBufferRange(pBuffer->mGlRes, pRange->mOffset, pRange->mSize, GL_MAP_WRITE_BIT);
	}

	void unmapBuffer(Renderer* pRenderer, Buffer* pBuffer)
	{
		ASSERT(pRenderer);

		glUnmapNamedBuffer(pBuffer->mGlRes);
	}
	/************************************************************************/
	// Shader Functions
	/************************************************************************/
	void compileShader(Renderer* pRenderer, ShaderStage stage, const char* fileName, uint32_t codeSize, const char* code, uint32_t macroCount, ShaderMacro* pMacros, void*(*allocator)(size_t a), uint32_t* pByteCodeSize, char** ppByteCode)
	{
		GLenum shaderType = util_to_gl_shader_type(stage);

		GLuint shader = glCreateShader(shaderType);

		glShaderSource(shader, 1, &code, NULL);

		glCompileShader(shader);

		GLint status;
		glGetShaderiv(shader, GL_COMPILE_STATUS, &status);

		if (status != GL_TRUE) {
			char msg[512];
			glGetShaderInfoLog(shader, 512, NULL, msg);
			String error = String(fileName) + " " + msg;
			ErrorMsg(error);
		}
		ASSERT(status == GL_TRUE);
	}

	// renderer shader macros allocated on stack
	const RendererShaderDefinesDesc get_renderer_shaderdefines(Renderer* pRenderer)
	{
		RendererShaderDefinesDesc defineDesc = { NULL , 0 };
		return defineDesc;
	}

	void addShaderBinary(Renderer* pRenderer, const BinaryShaderDesc* pDesc, Shader** ppShaderProgram)
	{
		//https://www.khronos.org/opengl/wiki/SPIR-V

		Shader* pShaderProgram = (Shader*)conf_calloc(1, sizeof(*pShaderProgram));
		pShaderProgram->mStages = pDesc->mStages;

		uint32_t counter = 0;
		ShaderReflection stageReflections[SHADER_STAGE_COUNT];
		tinystl::vector<GLuint> shaders(SHADER_STAGE_COUNT);

		for (uint32_t i = 0; i < SHADER_STAGE_COUNT; ++i)
		{
			ShaderStage stage_mask = (ShaderStage)(1 << i);
			if (stage_mask == (pShaderProgram->mStages & stage_mask))
			{
				switch (stage_mask) {
				case SHADER_STAGE_VERT: {
					gl_createShaderReflection((const uint8_t*)pDesc->mVert.pByteCode, pDesc->mVert.mByteCodeSize, SHADER_STAGE_VERT, &stageReflections[counter]);

					GLuint shader = glCreateShader(GL_VERTEX_SHADER);
					glShaderBinary(1, &shader, GL_SHADER_BINARY_FORMAT_SPIR_V_ARB, pDesc->mVert.pByteCode, pDesc->mVert.mByteCodeSize);
					glSpecializeShaderARB(shader, "main", 0, nullptr, nullptr);
					GLint status;
					glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
					shaders[counter] = shader;
				} break;
				case SHADER_STAGE_TESC: {
					gl_createShaderReflection((const uint8_t*)pDesc->mHull.pByteCode, pDesc->mHull.mByteCodeSize, SHADER_STAGE_TESC, &stageReflections[counter]);

					GLuint shader = glCreateShader(GL_TESS_CONTROL_SHADER);
					glShaderBinary(1, &shader, GL_SHADER_BINARY_FORMAT_SPIR_V_ARB, pDesc->mHull.pByteCode, pDesc->mHull.mByteCodeSize);
					glSpecializeShaderARB(shader, "main", 0, nullptr, nullptr);
					GLint status;
					glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
					shaders[counter] = shader;
				} break;
				case SHADER_STAGE_TESE: {
					gl_createShaderReflection((const uint8_t*)pDesc->mDomain.pByteCode, pDesc->mDomain.mByteCodeSize, SHADER_STAGE_TESE, &stageReflections[counter]);

					GLuint shader = glCreateShader(GL_TESS_EVALUATION_SHADER);
					glShaderBinary(1, &shader, GL_SHADER_BINARY_FORMAT_SPIR_V_ARB, pDesc->mDomain.pByteCode, pDesc->mDomain.mByteCodeSize);
					glSpecializeShaderARB(shader, "main", 0, nullptr, nullptr);
					GLint status;
					glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
					shaders[counter] = shader;
				} break;
				case SHADER_STAGE_GEOM: {
					gl_createShaderReflection((const uint8_t*)pDesc->mGeom.pByteCode, pDesc->mGeom.mByteCodeSize, SHADER_STAGE_GEOM, &stageReflections[counter]);

					GLuint shader = glCreateShader(GL_VERTEX_SHADER);
					glShaderBinary(1, &shader, GL_SHADER_BINARY_FORMAT_SPIR_V_ARB, pDesc->mGeom.pByteCode, pDesc->mGeom.mByteCodeSize);
					glSpecializeShaderARB(shader, "main", 0, nullptr, nullptr);
					GLint status;
					glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
					shaders[counter] = shader;
				} break;
				case SHADER_STAGE_FRAG: {
					gl_createShaderReflection((const uint8_t*)pDesc->mFrag.pByteCode, pDesc->mFrag.mByteCodeSize, SHADER_STAGE_FRAG, &stageReflections[counter]);

					GLuint shader = glCreateShader(GL_FRAGMENT_SHADER);
					glShaderBinary(1, &shader, GL_SHADER_BINARY_FORMAT_SPIR_V_ARB, pDesc->mFrag.pByteCode, pDesc->mFrag.mByteCodeSize);
					glSpecializeShaderARB(shader, "main", 0, nullptr, nullptr);
					GLint status;
					glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
					shaders[counter] = shader;
				} break;
				case SHADER_STAGE_COMP: {
					gl_createShaderReflection((const uint8_t*)pDesc->mComp.pByteCode, pDesc->mComp.mByteCodeSize, SHADER_STAGE_COMP, &stageReflections[counter]);

					GLuint shader = glCreateShader(GL_COMPUTE_SHADER);
					glShaderBinary(1, &shader, GL_SHADER_BINARY_FORMAT_SPIR_V_ARB, pDesc->mComp.pByteCode, pDesc->mComp.mByteCodeSize);
					glSpecializeShaderARB(shader, "main", 0, nullptr, nullptr);
					GLint status;
					glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
					shaders[counter] = shader;
				} break;
				}

				++counter;
			}
		}

		pShaderProgram->pGlShaders = (GLuint*)conf_calloc(counter, sizeof(GLuint));
		memcpy(pShaderProgram->pGlShaders, shaders.data(), counter * sizeof(GLuint));

		createPipelineReflection(stageReflections, counter, &pShaderProgram->mReflection);

		*ppShaderProgram = pShaderProgram;
	}

	void removeShader(Renderer* pRenderer, Shader* pShaderProgram)
	{
        ASSERT(pRenderer);

        if (pShaderProgram->mStages & SHADER_STAGE_VERT) {
            glDeleteShader(pShaderProgram->pGlShaders[pShaderProgram->mReflection.mVertexStageIndex]);
        }

        if (pShaderProgram->mStages & SHADER_STAGE_TESC) {
            glDeleteShader(pShaderProgram->pGlShaders[pShaderProgram->mReflection.mHullStageIndex]);
        }

        if (pShaderProgram->mStages & SHADER_STAGE_TESE) {
            glDeleteShader(pShaderProgram->pGlShaders[pShaderProgram->mReflection.mDomainStageIndex]);
        }

        if (pShaderProgram->mStages & SHADER_STAGE_GEOM) {
            glDeleteShader(pShaderProgram->pGlShaders[pShaderProgram->mReflection.mGeometryStageIndex]);
        }

        if (pShaderProgram->mStages & SHADER_STAGE_FRAG) {
            glDeleteShader(pShaderProgram->pGlShaders[pShaderProgram->mReflection.mPixelStageIndex]);
        }

        if (pShaderProgram->mStages & SHADER_STAGE_COMP) {
            glDeleteShader(pShaderProgram->pGlShaders[0]);
        }

        destroyPipelineReflection(&pShaderProgram->mReflection);

        SAFE_FREE(pShaderProgram->pGlShaders);
        SAFE_FREE(pShaderProgram);
    }
	/************************************************************************/
	// Root Signature Functions
	/************************************************************************/
	typedef struct DescriptorSetLayoutInfo
	{
		/// Array of descriptors in this descriptor set
		tinystl::vector<DescriptorInfo*> mDescriptors;
		/// Hash map to get index of the descriptor in the root signature
		tinystl::unordered_map<DescriptorInfo*, uint32_t> mDescriptorIndexMap;
	} DescriptorSetLayoutInfo;

	void addRootSignature(Renderer* pRenderer, const RootSignatureDesc* pDesc, RootSignature** ppRootSignature)
	{
		RootSignature* pRootSignature = (RootSignature*)conf_calloc(1, sizeof(*pRootSignature));

		tinystl::vector<DescriptorSetLayoutInfo> layouts(DESCRIPTOR_UPDATE_FREQ_COUNT);
		tinystl::vector<DescriptorInfo*> pushConstantDescriptors;
		tinystl::vector<ShaderResource const*> shaderResources;

		if (pDesc->mStaticSamplerCount) {
			pRootSignature->pSampler = pDesc->ppStaticSamplers[0];
		}

		// Collect all unique shader resources in the given shaders
		for (uint32_t s = 0; s < pDesc->mShaderCount; ++s)
		{
			PipelineReflection const* pReflection = &pDesc->ppShaders[s]->mReflection;

			if (pReflection->mShaderStages & SHADER_STAGE_COMP)
				pRootSignature->mPipelineType = PIPELINE_TYPE_COMPUTE;
			else
				pRootSignature->mPipelineType = PIPELINE_TYPE_GRAPHICS;

			for (uint32_t i = 0; i < pReflection->mShaderResourceCount; ++i)
			{
				ShaderResource const* pRes = &pReflection->pShaderResources[i];
				uint32_t setIndex = pRes->set;

				if (pRes->type == DESCRIPTOR_TYPE_ROOT_CONSTANT)
					setIndex = 0;

				if (pRootSignature->pDescriptorNameToIndexMap.find(tinystl::hash(pRes->name)).node == 0)
				{
					pRootSignature->pDescriptorNameToIndexMap.insert({ tinystl::hash(pRes->name), (uint32_t)shaderResources.size() });
					shaderResources.emplace_back(pRes);
				}
			}
		}

		if ((uint32_t)shaderResources.size())
		{
			pRootSignature->mDescriptorCount = (uint32_t)shaderResources.size();
			pRootSignature->pDescriptors = (DescriptorInfo*)conf_calloc(pRootSignature->mDescriptorCount, sizeof(DescriptorInfo));
		}

		// Fill the descriptor array to be stored in the root signature
		for (uint32_t i = 0; i < (uint32_t)shaderResources.size(); ++i)
		{
			DescriptorInfo* desc = &pRootSignature->pDescriptors[i];
			ShaderResource const* sres = shaderResources[i];
			uint32_t setIndex = sres->set;

			// Copy the binding information generated from the shader reflection into the descriptor
			desc->mDesc.reg = sres->reg;
			desc->mDesc.set = sres->set;
			desc->mDesc.size = sres->size;
			desc->mDesc.type = sres->type;
			desc->mDesc.used_stages = sres->used_stages;
			desc->mDesc.name_size = sres->name_size;
			desc->mDesc.name = (const char*)conf_calloc(desc->mDesc.name_size + 1, sizeof(char));
			memcpy((char*)desc->mDesc.name, sres->name, sres->name_size);

			// If descriptor is not a root constant create a new layout binding for this descriptor and add it to the binding array
			if (desc->mDesc.type != DESCRIPTOR_TYPE_ROOT_CONSTANT)
			{
				desc->mUpdateFrquency = (DescriptorUpdateFrequency)setIndex;

				//TODO:
				// Assign static descriptors to sampled_texture?

				layouts[setIndex].mDescriptors.emplace_back(desc);
			}
			// If descriptor is a root constant, add it to the root constant array
			else
			{
				setIndex = 0;
				desc->mDesc.set = setIndex;
				pushConstantDescriptors.emplace_back(desc);
			}

			layouts[setIndex].mDescriptorIndexMap[desc] = i;
		}

		pRootSignature->pGlDescriptorSetLayouts = (DescriptorSetLayout*)conf_calloc((uint32_t)layouts.size(), sizeof(*pRootSignature->pGlDescriptorSetLayouts));

		pRootSignature->mRootConstantCount = (uint32_t)pushConstantDescriptors.size();
		if (pRootSignature->mRootConstantCount)
			pRootSignature->pRootConstantLayouts = (RootConstantLayout*)conf_calloc(pRootSignature->mRootConstantCount, sizeof(*pRootSignature->pRootConstantLayouts));

		// Create push constant ranges
		for (uint32_t i = 0; i < pRootSignature->mRootConstantCount; ++i)
		{
			RootConstantLayout* pConst = &pRootSignature->pRootConstantLayouts[i];
			DescriptorInfo* desc = pushConstantDescriptors[i];
			desc->mIndexInParent = i;
			pConst->mDescriptorIndex = layouts[0].mDescriptorIndexMap[desc];
			//pConst->mVkPushConstantRange.offset = 0;
			//pConst->mVkPushConstantRange.size = desc->mDesc.size;
			//pConst->mVkPushConstantRange.stageFlags = util_to_vk_shader_stage_flags(desc->mDesc.used_stages);
		}

		// Create descriptor layouts
		// Put most frequently changed params first
		for (uint32_t i = (uint32_t)layouts.size(); i-- > 0U;)
		{
			DescriptorSetLayoutInfo* layoutInfo = &layouts[i];
			DescriptorSetLayout* layout = &pRootSignature->pGlDescriptorSetLayouts[i];

			if (!layoutInfo->mDescriptors.size())
				continue;

			layout->mDescriptorCount = (uint32_t)layoutInfo->mDescriptors.size();
			layout->pDescriptorIndices = (uint32_t*)conf_calloc(layout->mDescriptorCount, sizeof(uint32_t));

			// Loop through descriptors belonging to this update frequency and increment the cumulative descriptor count
			for (uint32_t descIndex = 0; descIndex < (uint32_t)layoutInfo->mDescriptors.size(); ++descIndex)
			{
				DescriptorInfo* pDesc = layoutInfo->mDescriptors[descIndex];
				pDesc->mIndexInParent = descIndex;
				layout->mCumulativeDescriptorCount += pDesc->mDesc.size;
				if (pDesc->mDesc.type == DESCRIPTOR_TYPE_BUFFER || pDesc->mDesc.type == DESCRIPTOR_TYPE_RW_BUFFER || pDesc->mDesc.type == DESCRIPTOR_TYPE_UNIFORM_BUFFER)
				{
					pDesc->mHandleIndex = layout->mCumulativeBufferDescriptorCount;
					layout->mCumulativeBufferDescriptorCount += pDesc->mDesc.size;
				}
				else
				{
					pDesc->mHandleIndex = layout->mCumulativeImageDescriptorCount;
					layout->mCumulativeImageDescriptorCount += pDesc->mDesc.size;
				}
				layout->pDescriptorIndices[descIndex] = layoutInfo->mDescriptorIndexMap[pDesc];
			}
		}

		conf_placement_new<RootSignature::ThreadLocalDescriptorManager>(&pRootSignature->pDescriptorManagerMap);
		// Create descriptor manager for this thread
		DescriptorManager* pManager = NULL;
		add_descriptor_manager(pRenderer, pRootSignature, &pManager);
		pRootSignature->pDescriptorManagerMap.insert({ Thread::GetCurrentThreadID(), pManager });

		*ppRootSignature = pRootSignature;
	}

	void removeRootSignature(Renderer* pRenderer, RootSignature* pRootSignature)
	{
		SAFE_FREE(pRootSignature);
	}
	/************************************************************************/
	// Pipeline State Functions
	/************************************************************************/
	GLint util_to_gl_vertexarrayattrib_size(ImageFormat::Enum format)
	{
		switch (format)
		{
		case ImageFormat::RG32F: return 2;
		case ImageFormat::RGB32F: return 3;
		case ImageFormat::RGBA32F: return 4;
		}
		return 0;
	}
	GLenum util_to_gl_vertexarrayattrib_type(ImageFormat::Enum format)
	{
		switch (format)
		{
		case ImageFormat::RG32F: return GL_FLOAT;
		case ImageFormat::RGB32F: return GL_FLOAT;
		case ImageFormat::RGBA32F: return GL_FLOAT;
		}
		return GL_UNKNOWN;
	}

	void addPipeline(Renderer* pRenderer, const GraphicsPipelineDesc* pDesc, Pipeline** ppPipeline)
	{
		ASSERT(pRenderer);
		ASSERT(pDesc);
		//ASSERT(pDesc->pShaderProgram);

		Pipeline* pPipeline = (Pipeline*)conf_calloc(1, sizeof(*pPipeline));
		ASSERT(pPipeline);

		const Shader* pShaderProgram = pDesc->pShaderProgram;
		const VertexLayout* pVertexLayout = pDesc->pVertexLayout;

		memcpy(&(pPipeline->mGraphics), pDesc, sizeof(*pDesc));
		pPipeline->mType = PIPELINE_TYPE_GRAPHICS;

		pPipeline->mGlProgramRes = glCreateProgram();

		// Create tempporary renderpass for pipeline creation
		//RenderPassDesc renderPassDesc = { 0 };
		//RenderPass* pRenderPass = NULL;
		//renderPassDesc.mRenderTargetCount = pDesc->mRenderTargetCount;
		//renderPassDesc.pColorFormats = pDesc->pColorFormats;
		//renderPassDesc.mSampleCount = pDesc->mSampleCount;
		//renderPassDesc.pSrgbValues = pDesc->pSrgbValues;
		//renderPassDesc.mDepthStencilFormat = pDesc->mDepthStencilFormat;
		//add_render_pass(pRenderer, &renderPassDesc, &pRenderPass);

		//https://www.khronos.org/opengl/wiki/GLSL_Object#Program_pipeline_objects
		uint32_t stage_count = 0;
		for (uint32_t i = 0; i < 5; ++i) {
			ShaderStage stage_mask = (ShaderStage)(1 << i);
			if (stage_mask == (pShaderProgram->mStages & stage_mask)) {
				glAttachShader(pPipeline->mGlProgramRes, pShaderProgram->pGlShaders[stage_count]);
				// TODO: entry-point specialization
				//switch (stage_mask) {
				//case SHADER_STAGE_VERT: {
				//} break;
				//case SHADER_STAGE_TESC: {
				//} break;
				//case SHADER_STAGE_TESE: {
				//} break;
				//case SHADER_STAGE_GEOM: {
				//} break;
				//case SHADER_STAGE_FRAG: {
				//} break;
				//}
				++stage_count;
			}
		}

		// Make sure there's a shader
		ASSERT(0 != stage_count);

		glLinkProgram(pPipeline->mGlProgramRes);

		uint32_t input_binding_count = 0;
		uint32_t input_attribute_count = 0;

		if (pVertexLayout != NULL)
		{
			// Ignore everything that's beyond max_vertex_attribs
			uint32_t attrib_count = pVertexLayout->mAttribCount > MAX_VERTEX_ATTRIBS ? MAX_VERTEX_ATTRIBS : pVertexLayout->mAttribCount;
			uint32_t binding_value = UINT32_MAX;

			glCreateVertexArrays(1, &pPipeline->mGlVaoRes);

			for (uint32_t i = 0; i < attrib_count; ++i)
			{
				const VertexAttrib* attrib = &pVertexLayout->mAttribs[i];

				if (binding_value != attrib->mBinding)
				{
					binding_value = attrib->mBinding;
					++input_binding_count;
				}

				++input_attribute_count;

				GLint size = util_to_gl_vertexarrayattrib_size(attrib->mFormat);
				GLenum type = util_to_gl_vertexarrayattrib_type(attrib->mFormat);

				glEnableVertexArrayAttrib(pPipeline->mGlVaoRes, attrib->mLocation);
				glVertexArrayAttribFormat(pPipeline->mGlVaoRes, attrib->mLocation, size, type, GL_FALSE, attrib->mOffset);
				glVertexArrayAttribBinding(pPipeline->mGlVaoRes, attrib->mLocation, attrib->mBinding);
			}
		}

		*ppPipeline = pPipeline;
	}

	void addComputePipeline(Renderer* pRenderer, const ComputePipelineDesc* pDesc, Pipeline** ppPipeline)
	{
		ASSERT(pRenderer);
		ASSERT(pDesc);
		ASSERT(pDesc->pShaderProgram);
		ASSERT(pDesc->pRootSignature);

		Pipeline* pPipeline = (Pipeline*)conf_calloc(1, sizeof(*pPipeline));
		ASSERT(pPipeline);

		memcpy(&(pPipeline->mCompute), pDesc, sizeof(*pDesc));
		pPipeline->mType = PIPELINE_TYPE_COMPUTE;

		pPipeline->mGlProgramRes = glCreateProgram();

		glLinkProgram(pPipeline->mGlProgramRes);

		*ppPipeline = pPipeline;
	}

	void removePipeline(Renderer* pRenderer, Pipeline* pPipeline)
	{
		ASSERT(pRenderer);
		ASSERT(pPipeline);

		glDeleteProgram(pPipeline->mGlProgramRes);

		SAFE_FREE(pPipeline);
	}

	void addBlendState(Renderer* pRenderer, const BlendStateDesc* pDesc, BlendState** ppBlendState)
	{
	}

	void removeBlendState(BlendState* pBlendState)
	{
		SAFE_FREE(pBlendState);
	}

	void addDepthState(Renderer* pRenderer, const DepthStateDesc* pDesc, DepthState** ppDepthState)
	{
		ASSERT(pDesc->mDepthFunc < CompareMode::MAX_COMPARE_MODES);
		ASSERT(pDesc->mStencilFrontFunc < CompareMode::MAX_COMPARE_MODES);
		ASSERT(pDesc->mStencilFrontFail < StencilOp::MAX_STENCIL_OPS);
		ASSERT(pDesc->mDepthFrontFail < StencilOp::MAX_STENCIL_OPS);
		ASSERT(pDesc->mStencilFrontPass < StencilOp::MAX_STENCIL_OPS);
		ASSERT(pDesc->mStencilBackFunc < CompareMode::MAX_COMPARE_MODES);
		ASSERT(pDesc->mStencilBackFail < StencilOp::MAX_STENCIL_OPS);
		ASSERT(pDesc->mDepthBackFail < StencilOp::MAX_STENCIL_OPS);
		ASSERT(pDesc->mStencilBackPass < StencilOp::MAX_STENCIL_OPS);

		DepthState depthState = {};
		depthState.mDepthTest = pDesc->mDepthTest;
		depthState.mGlDepthMask = pDesc->mDepthWrite ? GL_TRUE : GL_FALSE;
		//depthState.DepthCompareOp = gVkComparisonFuncTranslator[pDesc->mDepthFunc];
		//depthState.StencilTestEnable = pDesc->mStencilTest;

		//depthState.Front.failOp = gVkStencilOpTranslator[pDesc->mStencilFrontFail];
		//depthState.Front.passOp = gVkStencilOpTranslator[pDesc->mStencilFrontPass];
		//depthState.Front.depthFailOp = gVkStencilOpTranslator[pDesc->mDepthFrontFail];
		//depthState.Front.compareOp = VkCompareOp(pDesc->mStencilFrontFunc);
		//depthState.Front.compareMask = pDesc->mStencilReadMask;
		//depthState.Front.writeMask = pDesc->mStencilWriteMask;
		//depthState.Front.reference = 0;
		//
		//depthState.Back.failOp = gVkStencilOpTranslator[pDesc->mStencilBackFail];
		//depthState.Back.passOp = gVkStencilOpTranslator[pDesc->mStencilBackPass];
		//depthState.Back.depthFailOp = gVkStencilOpTranslator[pDesc->mDepthBackFail];
		//depthState.Back.compareOp = gVkComparisonFuncTranslator[pDesc->mStencilBackFunc];
		//depthState.Back.compareMask = pDesc->mStencilReadMask;
		//depthState.Back.writeMask = pDesc->mStencilFrontFunc;
		//depthState.Back.reference = 0;

		//depthState.DepthBoundsTestEnable = false;
		//depthState.MinDepthBounds = 0;
		//depthState.MaxDepthBounds = 1;

		*ppDepthState = (DepthState*)conf_malloc(sizeof(depthState));
		memcpy(*ppDepthState, &depthState, sizeof(depthState));
	}

	void removeDepthState(DepthState* pDepthState)
	{
		SAFE_FREE(pDepthState);
	}

	void addRasterizerState(Renderer* pRenderer, const RasterizerStateDesc* pDesc, RasterizerState** ppRasterizerState)
	{
	}

	void removeRasterizerState(RasterizerState* pRasterizerState)
	{
	}
	/************************************************************************/
	// Command buffer Functions
	/************************************************************************/
	void beginCmd(Cmd* pCmd)
	{
		ASSERT(pCmd);

		// reset buffer
		pCmd->pGlCmdList->mCmds.clear();
	}

	void endCmd(Cmd* pCmd)
	{
		ASSERT(pCmd);
	}

	GLenum util_to_gl_color_attachment(uint32_t attachment) {
		switch (attachment)
		{
		case 0: return GL_COLOR_ATTACHMENT0;
		case 1: return GL_COLOR_ATTACHMENT1;
		case 2: return GL_COLOR_ATTACHMENT2;
		case 3: return GL_COLOR_ATTACHMENT3;
		case 4: return GL_COLOR_ATTACHMENT4;
		case 5: return GL_COLOR_ATTACHMENT5;
		case 6: return GL_COLOR_ATTACHMENT6;
		case 7: return GL_COLOR_ATTACHMENT7;
		}
		return GL_UNKNOWN;
	}

	void cmdBindRenderTargets(Cmd* pCmd, uint32_t renderTargetCount, RenderTarget** ppRenderTargets, RenderTarget* pDepthStencil, const LoadActionsDesc* pLoadActions/* = NULL*/)
	{
		ASSERT(pCmd);

		GlContextState* contextState = pCmd->pRenderer->pGlContextState;

		// Process clear actions
		if (pLoadActions)
		{
			for (uint32_t i = 0; i < renderTargetCount; ++i)
			{
				RenderTarget* pRenderTarget = ppRenderTargets[i];

				if (pLoadActions->mLoadActionsColor[i] == LOAD_ACTION_CLEAR)
				{
					GLenum buffer;
					if (pRenderTarget->mDesc.mDefaultFramebufferOwned)
						buffer = GL_BACK;
					else
						buffer = util_to_gl_color_attachment(i);

					if (contextState->mDrawBuffer != buffer)
					{
						DECLARE_ZERO(GlCmd, cmd);
						cmd.mDrawBuffer.sType = GL_STRUCTURE_TYPE_COMMAND_DrawBuffer;
						cmd.mDrawBuffer.mBuf = buffer;
						pCmd->pGlCmdList->mCmds.push_back(cmd);

						contextState->mDrawBuffer = buffer;
					}

					if (contextState->mClearColor.mRed != pLoadActions->mClearColorValues[i].r ||
						contextState->mClearColor.mGreen != pLoadActions->mClearColorValues[i].g ||
						contextState->mClearColor.mBlue != pLoadActions->mClearColorValues[i].b ||
						contextState->mClearColor.mAlpha != pLoadActions->mClearColorValues[i].a)
					{
						DECLARE_ZERO(GlCmd, cmd);
						cmd.mClearColor.sType = GL_STRUCTURE_TYPE_COMMAND_ClearColor;
						cmd.mClearColor.mRed = pLoadActions->mClearColorValues[i].r;
						cmd.mClearColor.mGreen = pLoadActions->mClearColorValues[i].g;
						cmd.mClearColor.mBlue = pLoadActions->mClearColorValues[i].b;
						cmd.mClearColor.mAlpha = pLoadActions->mClearColorValues[i].a;
						pCmd->pGlCmdList->mCmds.push_back(cmd);

						contextState->mClearColor.mRed = pLoadActions->mClearColorValues[i].r;
						contextState->mClearColor.mGreen = pLoadActions->mClearColorValues[i].g;
						contextState->mClearColor.mBlue = pLoadActions->mClearColorValues[i].b;
						contextState->mClearColor.mAlpha = pLoadActions->mClearColorValues[i].a;
					}

					DECLARE_ZERO(GlCmd, cmd);
					cmd.mClear.sType = GL_STRUCTURE_TYPE_COMMAND_Clear;
					cmd.mClear.mMask = GL_COLOR_BUFFER_BIT;
					pCmd->pGlCmdList->mCmds.push_back(cmd);
				}
			}
			if (pLoadActions->mLoadActionDepth == LOAD_ACTION_CLEAR || pLoadActions->mLoadActionStencil == LOAD_ACTION_CLEAR)
			{
				GLbitfield mask = 0;

				if (pLoadActions->mLoadActionDepth == LOAD_ACTION_CLEAR)
				{
					mask |= GL_DEPTH_BUFFER_BIT;

					if (contextState->mClearDepth != pLoadActions->mClearDepth.depth)
					{
						DECLARE_ZERO(GlCmd, cmd);
						cmd.mClearDepth.sType = GL_STRUCTURE_TYPE_COMMAND_ClearDepth;
						cmd.mClearDepth.mDepth = pLoadActions->mClearDepth.depth;
						pCmd->pGlCmdList->mCmds.push_back(cmd);

						contextState->mClearDepth = pLoadActions->mClearDepth.depth;
					}
				}

				if (pLoadActions->mLoadActionStencil == LOAD_ACTION_CLEAR)
				{
					mask |= GL_STENCIL_BUFFER_BIT;

					if (contextState->mClearStencil != pLoadActions->mClearDepth.stencil)
					{
						DECLARE_ZERO(GlCmd, cmd);
						cmd.mClearStencil.sType = GL_STRUCTURE_TYPE_COMMAND_ClearStencil;
						cmd.mClearStencil.mS = pLoadActions->mClearDepth.stencil;
						pCmd->pGlCmdList->mCmds.push_back(cmd);

						contextState->mClearStencil = pLoadActions->mClearDepth.stencil;
					}
				}

				DECLARE_ZERO(GlCmd, cmd);
				cmd.mClear.sType = GL_STRUCTURE_TYPE_COMMAND_Clear;
				cmd.mClear.mMask = mask;
				pCmd->pGlCmdList->mCmds.push_back(cmd);
			}
		}
	}

	void cmdSetViewport(Cmd* pCmd, float x, float y, float width, float height, float minDepth, float maxDepth)
	{
		GlContextState* contextState = pCmd->pRenderer->pGlContextState;

		if (contextState->mViewport.mX == x && contextState->mViewport.mY == y && contextState->mViewport.mWidth == width && contextState->mViewport.mHeight == height)
			return;

		DECLARE_ZERO(GlCmd, cmd);
		cmd.mViewport.sType = GL_STRUCTURE_TYPE_COMMAND_Viewport;
		cmd.mViewport.mX = (GLint)x;
		cmd.mViewport.mY = (GLint)y;
		cmd.mViewport.mWidth = (GLsizei)width;
		cmd.mViewport.mHeight = (GLsizei)height;
		pCmd->pGlCmdList->mCmds.push_back(cmd);

		contextState->mViewport.mX = (GLint)x;
		contextState->mViewport.mY = (GLint)y;
		contextState->mViewport.mWidth = (GLsizei)width;
		contextState->mViewport.mHeight = (GLsizei)height;
	}

	void cmdSetScissor(Cmd* pCmd, uint32_t x, uint32_t y, uint32_t width, uint32_t height)
	{
		GlContextState* contextState = pCmd->pRenderer->pGlContextState;

		if (contextState->mScissor.mX == x && contextState->mScissor.mY == y && contextState->mScissor.mWidth == width && contextState->mScissor.mHeight == height)
			return;

		DECLARE_ZERO(GlCmd, cmd);
		cmd.mScissor.sType = GL_STRUCTURE_TYPE_COMMAND_Scissor;
		cmd.mScissor.mX = x;
		cmd.mScissor.mY = y;
		cmd.mScissor.mWidth = (GLsizei)width;
		cmd.mScissor.mHeight = (GLsizei)height;
		pCmd->pGlCmdList->mCmds.push_back(cmd);

		contextState->mScissor.mX = (GLint)x;
		contextState->mScissor.mY = (GLint)y;
		contextState->mScissor.mWidth = (GLsizei)width;
		contextState->mScissor.mHeight = (GLsizei)height;
	}

	void cmdBindPipeline(Cmd* pCmd, Pipeline* pPipeline)
	{
		GlContextState* contextState = pCmd->pRenderer->pGlContextState;

		contextState->mDrawPrimitiveMode = util_to_gl_primitive_topology_type(pPipeline->mGraphics.mPrimitiveTopo);

		DepthState* pDepthState = pPipeline->mGraphics.pDepthState;

		bool depthTest = pDepthState ? pDepthState->mDepthTest : false;

		if (contextState->mEnableDepthTest != depthTest) {
			contextState->mEnableDepthTest = depthTest;

			if (depthTest) {
				DECLARE_ZERO(GlCmd, cmd);
				cmd.mEnable.sType = GL_STRUCTURE_TYPE_COMMAND_Enable;
				cmd.mEnable.mCap = GL_DEPTH_TEST;
				pCmd->pGlCmdList->mCmds.push_back(cmd);

				if (contextState->mDepthMask != pDepthState->mGlDepthMask) {
					contextState->mDepthMask = pDepthState->mGlDepthMask;

					DECLARE_ZERO(GlCmd, cmd);
					cmd.mDepthMask.sType = GL_STRUCTURE_TYPE_COMMAND_DepthMask;
					cmd.mDepthMask.mFlag = pDepthState->mGlDepthMask;
					pCmd->pGlCmdList->mCmds.push_back(cmd);
				}
			}
			else {
				DECLARE_ZERO(GlCmd, cmd);
				cmd.mDisable.sType = GL_STRUCTURE_TYPE_COMMAND_Disable;
				cmd.mDisable.mCap = GL_DEPTH_TEST;
				pCmd->pGlCmdList->mCmds.push_back(cmd);
			}
		}

		if (contextState->mProgram != pPipeline->mGlProgramRes)
		{
			DECLARE_ZERO(GlCmd, cmd);
			cmd.mUseProgram.sType = GL_STRUCTURE_TYPE_COMMAND_UseProgram;
			cmd.mUseProgram.mProgram = pPipeline->mGlProgramRes;
			pCmd->pGlCmdList->mCmds.push_back(cmd);

			contextState->mProgram = pPipeline->mGlProgramRes;
		}

		{
			DECLARE_ZERO(GlCmd, cmd);
			cmd.mBindVertexArray.sType = GL_STRUCTURE_TYPE_COMMAND_BindVertexArray;
			cmd.mBindVertexArray.mArray = pPipeline->mGlVaoRes;
			pCmd->pGlCmdList->mCmds.push_back(cmd);
		}

		pCmd->mGlBoundVao = pPipeline->mGlVaoRes;
	}

	void cmdBindIndexBuffer(Cmd* pCmd, Buffer* pBuffer)
	{
		ASSERT(pCmd);
		ASSERT(pBuffer);

		DECLARE_ZERO(GlCmd, cmd);
		cmd.mVertexArrayElementBuffer.sType = GL_STRUCTURE_TYPE_COMMAND_VertexArrayElementBuffer;
		cmd.mVertexArrayElementBuffer.mVaobj = pCmd->mGlBoundVao;
		cmd.mVertexArrayElementBuffer.mBuffer = pBuffer->mGlRes;
		pCmd->pGlCmdList->mCmds.push_back(cmd);
	}

	void cmdBindVertexBuffer(Cmd* pCmd, uint32_t bufferCount, Buffer** ppBuffers)
	{
		ASSERT(pCmd);
		ASSERT(bufferCount != 0);
		ASSERT(bufferCount <= MAX_VERTEX_BINDINGS);
		ASSERT(ppBuffers);

		for (uint32_t i = 0; i < bufferCount; ++i) {
			DECLARE_ZERO(GlCmd, cmd);
			cmd.mVertexArrayVertexBuffer.sType = GL_STRUCTURE_TYPE_COMMAND_VertexArrayVertexBuffer;
			cmd.mVertexArrayVertexBuffer.mVaobj = pCmd->mGlBoundVao;
			cmd.mVertexArrayVertexBuffer.mBindingindex = i;
			cmd.mVertexArrayVertexBuffer.mBuffer = ppBuffers[i]->mGlRes;
			cmd.mVertexArrayVertexBuffer.mOffset = ppBuffers[i]->mPositionInHeap;
			cmd.mVertexArrayVertexBuffer.mStride = ppBuffers[i]->mDesc.mVertexStride;
			pCmd->pGlCmdList->mCmds.push_back(cmd);
		}
	}

	void cmdDraw(Cmd* pCmd, uint32_t vertexCount, uint32_t firstVertex)
	{
		ASSERT(pCmd);
		ASSERT(0 != vertexCount);

		GlContextState* contextState = pCmd->pRenderer->pGlContextState;

		DECLARE_ZERO(GlCmd, cmd);
		cmd.mDrawArrays.sType = GL_STRUCTURE_TYPE_COMMAND_DrawArrays;
		cmd.mDrawArrays.mMode = contextState->mDrawPrimitiveMode;
		cmd.mDrawArrays.mFirst = firstVertex;
		cmd.mDrawArrays.mCount = vertexCount;
		pCmd->pGlCmdList->mCmds.push_back(cmd);
	}

	void cmdDrawInstanced(Cmd* pCmd, uint32_t vertexCount, uint32_t firstVertex, uint32_t instanceCount)
	{
		ASSERT(pCmd);
		ASSERT(0 != vertexCount);
		ASSERT(0 != instanceCount);

		GlContextState* contextState = pCmd->pRenderer->pGlContextState;

		DECLARE_ZERO(GlCmd, cmd);
		cmd.mDrawArraysInstanced.sType = GL_STRUCTURE_TYPE_COMMAND_DrawArraysInstanced;
		cmd.mDrawArraysInstanced.mMode = contextState->mDrawPrimitiveMode;
		cmd.mDrawArraysInstanced.mFirst = firstVertex;
		cmd.mDrawArraysInstanced.mCount = vertexCount;
		cmd.mDrawArraysInstanced.mInstancecount = instanceCount;
		pCmd->pGlCmdList->mCmds.push_back(cmd);
	}

	void cmdDrawIndexed(Cmd* pCmd, uint32_t indexCount, uint32_t firstIndex)
	{
		ASSERT(pCmd);
		ASSERT(0 != indexCount);

		GlContextState* contextState = pCmd->pRenderer->pGlContextState;

		DECLARE_ZERO(GlCmd, cmd);
		cmd.mDrawElements.sType = GL_STRUCTURE_TYPE_COMMAND_DrawElements;
		cmd.mDrawElements.mMode = contextState->mDrawPrimitiveMode;
		cmd.mDrawElements.mCount = indexCount;
		cmd.mDrawElements.mType = GL_UNSIGNED_INT;
		cmd.mDrawElements.mIndices = (void*)0; // element array buffer offset
		pCmd->pGlCmdList->mCmds.push_back(cmd);
	}

	void cmdDrawIndexedInstanced(Cmd* pCmd, uint32_t indexCount, uint32_t firstIndex, uint32_t instanceCount)
	{
		ASSERT(pCmd);
		ASSERT(0 != indexCount);

		GlContextState* contextState = pCmd->pRenderer->pGlContextState;

		DECLARE_ZERO(GlCmd, cmd);
		cmd.mDrawElementsInstanced.sType = GL_STRUCTURE_TYPE_COMMAND_DrawElementsInstanced;
		cmd.mDrawElementsInstanced.mMode = contextState->mDrawPrimitiveMode;
		cmd.mDrawElementsInstanced.mCount = indexCount;
		cmd.mDrawElementsInstanced.mType = GL_UNSIGNED_INT;
		cmd.mDrawElementsInstanced.mIndices = (void*)0; // element array buffer offset
		cmd.mDrawElementsInstanced.mInstancecount = instanceCount;
		pCmd->pGlCmdList->mCmds.push_back(cmd);
	}

	void cmdDispatch(Cmd* pCmd, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
	{
		ASSERT(pCmd);
		ASSERT(0 != groupCountX);
		ASSERT(0 != groupCountY);
		ASSERT(0 != groupCountZ);

		DECLARE_ZERO(GlCmd, cmd);
		cmd.mDispatchCompute.sType = GL_STRUCTURE_TYPE_COMMAND_DispatchCompute;
		cmd.mDispatchCompute.mNum_Groups_X = groupCountX;
		cmd.mDispatchCompute.mNum_Groups_Y = groupCountY;
		cmd.mDispatchCompute.mNum_Groups_Z = groupCountZ;
		pCmd->pGlCmdList->mCmds.push_back(cmd);
	}

	void cmdBindDescriptors(Cmd* pCmd, RootSignature* pRootSignature, uint32_t numParams, DescriptorData* pDescParams)
	{
		ASSERT(pCmd);
		ASSERT(pRootSignature);
		ASSERT(0 != numParams);
		ASSERT(pDescParams);

		Renderer* pRenderer = pCmd->pRenderer;
		const uint32_t setCount = DESCRIPTOR_UPDATE_FREQ_COUNT;
		DescriptorManager* pm = get_descriptor_manager(pRenderer, pRootSignature);

		if (pm->pCurrentCmd != pCmd)
		{
			pm->pCurrentCmd = pCmd;
			pm->mFrameIdx = (pm->mFrameIdx + 1) % MAX_FRAMES_IN_FLIGHT;
		}

		Sampler* sampler = pRootSignature->pSampler;
		GLuint texUnit = 0;

		// Loop through input params to check for new data
		for (uint32_t i = 0; i < numParams; ++i)
		{
			const DescriptorData* pParam = &pDescParams[i];
			ASSERT(pParam);
			if (!pParam->pName)
			{
				LOGERRORF("Name of Descriptor at index (%u) is NULL", i);
				return;
			}

			uint32_t descIndex = -1;
			const DescriptorInfo* pDesc = get_descriptor(pRootSignature, pParam->pName, &descIndex);
			if (!pDesc)
				continue;

			// Find the update frequency of the descriptor
			// This is also the set index to be used in vkCmdBindDescriptorSets
			const DescriptorUpdateFrequency setIndex = pDesc->mUpdateFrquency;
			const uint32_t arrayCount = max(1U, pParam->mCount);

			// If input param is a root constant no need to do any further checks
			if (pDesc->mDesc.type == DESCRIPTOR_TYPE_ROOT_CONSTANT)
			{
				//vkCmdPushConstants(pCmd->pVkCmdBuf, pRootSignature->pPipelineLayout, pDesc->mVkStages, 0, pDesc->mDesc.size, pParam->pRootConstant);
				continue;
			}

			// Generate hash of all the resource ids
			if (pDesc->mDesc.type == DESCRIPTOR_TYPE_SAMPLER)
			{
				// Update sampler for next sampled textures
				sampler = pParam->ppSamplers[i];
			}
			else if (pDesc->mDesc.type == DESCRIPTOR_TYPE_TEXTURE || pDesc->mDesc.type == DESCRIPTOR_TYPE_RW_TEXTURE)
			{
				if (!pParam->ppTextures) {
					LOGERRORF("Texture descriptor (%s) is NULL", pParam->pName);
					return;
				}
				for (uint32_t i = 0; i < arrayCount; ++i)
				{
					if (!pParam->ppTextures[i]) {
						LOGERRORF("Texture descriptor (%s) at array index (%u) is NULL", pParam->pName, i);
						return;
					}

					// binding should be obtained from reflection.
					{
						DECLARE_ZERO(GlCmd, cmd);
						cmd.mBindTextureUnit.sType = GL_STRUCTURE_TYPE_COMMAND_BindTextureUnit;
						cmd.mBindTextureUnit.mUnit = texUnit;
						cmd.mBindTextureUnit.mTexture = pParam->ppTextures[i]->mGlRes;
						pCmd->pGlCmdList->mCmds.push_back(cmd);
					}
					{
						DECLARE_ZERO(GlCmd, cmd);
						cmd.mBindSampler.sType = GL_STRUCTURE_TYPE_COMMAND_BindSampler;
						cmd.mBindSampler.mUnit = texUnit;
						cmd.mBindSampler.mSampler = sampler->mGlRes;
						pCmd->pGlCmdList->mCmds.push_back(cmd);
					}

					texUnit++;

					//// Store the new descriptor so we can use it in vkUpdateDescriptorSet later
					//pm->pImageInfo[setIndex][pDesc->mHandleIndex + i] = pParam->ppTextures[i]->mVkTextureView;
					//// SRVs need to be in VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL and UAVs need to be in VK_IMAGE_LAYOUT_GENERAL
					//if (pDesc->mDesc.type == DESCRIPTOR_TYPE_TEXTURE)
					//	pm->pImageInfo[setIndex][pDesc->mHandleIndex + i].imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
					//else
					//	pm->pImageInfo[setIndex][pDesc->mHandleIndex + i].imageLayout = VK_IMAGE_LAYOUT_GENERAL;
				}
			}
			else
			{
				if (!pParam->ppBuffers) {
					LOGERRORF("Buffer descriptor (%s) is NULL", pParam->pName);
					return;
				}
				for (uint32_t i = 0; i < arrayCount; ++i)
				{
					if (!pParam->ppBuffers[i]) {
						LOGERRORF("Buffer descriptor (%s) at array index (%u) is NULL", pParam->pName, i);
						return;
					}

					{
						DECLARE_ZERO(GlCmd, cmd);
						cmd.mBindBufferRange.sType = GL_STRUCTURE_TYPE_COMMAND_BindBufferRange;
						cmd.mBindBufferRange.mTarget = GL_UNIFORM_BUFFER;
						cmd.mBindBufferRange.mIndex = pDesc->mDesc.reg;
						cmd.mBindBufferRange.mBuffer = pParam->ppBuffers[i]->mGlRes;
						cmd.mBindBufferRange.mOffset = pParam->mOffset;
						cmd.mBindBufferRange.mSize = pParam->ppBuffers[i]->mDesc.mSize;
						pCmd->pGlCmdList->mCmds.push_back(cmd);
					}

					// Store the new descriptor so we can use it later
					//pm->pBufferInfo[setIndex][pDesc->mHandleIndex + i].mBuffer = pParam->ppBuffers[i]->mGlRes;
					//pm->pBufferInfo[setIndex][pDesc->mHandleIndex + i].mOffset = pParam->mOffset;
				}
			}

			//GlDescriptor* pDescriptor;
			//GlDescriptor* pSets[] = { &pDescriptor };
			//consume_descriptor(pRenderer, pSets, 1, pRenderer->pDescriptorPool);
			//
			//cmdBindDescriptorSet(pCmd, setIndex, &pDescriptor, rootDescCount);
			//++pm->mDescriptorSetCount[pm->mFrameIdx][setIndex];
		}
	}

	void cmdResourceBarrier(Cmd* pCmd, uint32_t numBufferBarriers, BufferBarrier* pBufferBarriers, uint32_t numTextureBarriers, TextureBarrier* pTextureBarriers, bool batch)
	{
	}

	void cmdSynchronizeResources(Cmd* pCmd, uint32_t numBuffers, Buffer** ppBuffers, uint32_t numTextures, Texture** ppTextures, bool batch)
	{
	}

	void cmdFlushBarriers(Cmd* pCmd)
	{
	}

	void cmdUpdateBuffer(Cmd* pCmd, uint64_t srcOffset, uint64_t dstOffset, uint64_t size, Buffer* pSrcBuffer, Buffer* pBuffer)
	{
		ASSERT(pCmd);
		ASSERT(pSrcBuffer);
		ASSERT(pSrcBuffer->mGlRes);
		ASSERT(pBuffer);
		ASSERT(pBuffer->mGlRes);
		ASSERT(srcOffset + size <= pSrcBuffer->mDesc.mSize);
		ASSERT(dstOffset + size <= pBuffer->mDesc.mSize);

		glFlushMappedNamedBufferRange(pSrcBuffer->mGlRes, srcOffset, size);

		{
			DECLARE_ZERO(GlCmd, cmd);
			cmd.mCopyNamedBufferSubData.sType = GL_STRUCTURE_TYPE_COMMAND_CopyNamedBufferSubData;
			cmd.mCopyNamedBufferSubData.mReadbuffer = pSrcBuffer->mGlRes;
			cmd.mCopyNamedBufferSubData.mWritebuffer = pBuffer->mGlRes;
			cmd.mCopyNamedBufferSubData.mReadoffset = srcOffset;
			cmd.mCopyNamedBufferSubData.mWriteoffset = dstOffset;
			cmd.mCopyNamedBufferSubData.mSize = size;
			pCmd->pGlCmdList->mCmds.push_back(cmd);
		}
	}

	void cmdUpdateSubresources(Cmd* pCmd, uint32_t startSubresource, uint32_t numSubresources, SubresourceDataDesc* pSubresources, Buffer* pIntermediate, uint64_t intermediateOffset, Texture* pTexture)
	{
        switch (pTexture->mDesc.mType)
        {
        case TEXTURE_TYPE_1D:
            break;
        case TEXTURE_TYPE_2D:
        {
            glBindTexture(GL_TEXTURE_2D, pTexture->mGlRes);

            GLenum format = util_to_gl_texture_format(pTexture->mDesc.mFormat);
            GLenum type = util_to_gl_texture_type(pTexture->mDesc.mFormat);

            for (uint32_t i = startSubresource; i < startSubresource + numSubresources; ++i)
            {
                SubresourceDataDesc* pRes = &pSubresources[i];

				glTexSubImage2D(GL_TEXTURE_2D, pRes->mMipLevel, 0, 0, pRes->mWidth, pRes->mHeight, format, type, pRes->pData);
            }
        }
        case TEXTURE_TYPE_3D:
            break;
        case TEXTURE_TYPE_CUBE:
            break;
        default:
            break;
        }
	}
	/************************************************************************/
	// Queue Fence Semaphore Functions
	/************************************************************************/
	void acquireNextImage(Renderer* pRenderer, SwapChain* pSwapChain, Semaphore* pSignalSemaphore, Fence* pFence, uint32_t* pSwapChainImageIndex)
	{
		UNREF_PARAM(pRenderer);
		UNREF_PARAM(pSignalSemaphore);
		UNREF_PARAM(pFence);

		GlContextState* contextState = pRenderer->pGlContextState;

		*pSwapChainImageIndex = (*pSwapChainImageIndex + 1) % pSwapChain->mDesc.mImageCount;

		RenderTarget* pRenderTarget = pSwapChain->ppSwapchainRenderTargets[*pSwapChainImageIndex];

		contextState->mEnableDepthTest = glIsEnabled(GL_DEPTH_TEST);
		contextState->mDepthMask = true;
		contextState->mScissor = { 0, 0, (GLsizei)pRenderTarget->mDesc.mWidth, (GLsizei)pRenderTarget->mDesc.mHeight };
		contextState->mViewport = { 0, 0, (GLsizei)pRenderTarget->mDesc.mWidth, (GLsizei)pRenderTarget->mDesc.mHeight };
		contextState->mDrawBuffer = GL_BACK;
		contextState->mClearDepth = 1.0f;
		contextState->mClearStencil = 0;
		contextState->mProgram = 0;
	}

	void queueSubmit(Queue* pQueue, uint32_t cmdCount, Cmd** ppCmds, Fence* pFence, uint32_t waitSemaphoreCount, Semaphore** ppWaitSemaphores, uint32_t signalSemaphoreCount, Semaphore** ppSignalSemaphores)
	{
		UNREF_PARAM(pQueue);

		// submit OpenGL commands.
		Cmd* pCmd = *ppCmds;
		for (; pCmd != *ppCmds + cmdCount; ++pCmd) {
			tinystl::vector<GlCmd>& glCmdListCmds = pCmd->pGlCmdList->mCmds;

			GlCmd* pGlCmd = glCmdListCmds.data();
			size_t glCmdSize = glCmdListCmds.size();

			glCmdSubmitv(pGlCmd, glCmdSize);
		}

		queueSignal(pQueue, pFence);
	}

	void queuePresent(Queue* pQueue, SwapChain* pSwapChain, uint32_t swapChainImageIndex, uint32_t waitSemaphoreCount, Semaphore** ppWaitSemaphores)
	{
		UNREF_PARAM(pQueue);
		UNREF_PARAM(swapChainImageIndex);
		UNREF_PARAM(waitSemaphoreCount);
		UNREF_PARAM(ppWaitSemaphores);

		glfwSwapBuffers((GLFWwindow *)pSwapChain->pContextView);
	}

	void waitForFences(Queue* pQueue, uint32_t fenceCount, Fence** ppFences, bool signal)
	{
		ASSERT(pQueue);
		ASSERT(fenceCount);
		ASSERT(ppFences);

		if (signal)
			glFinish();

		for (uint32_t i = 0; i < fenceCount; ++i)
		{
			if (ppFences[i]->mSubmitted)
				glClientWaitSync(ppFences[i]->mGlSync, 0, GL_TIMEOUT_IGNORED);
		}

		for (uint32_t i = 0; i < fenceCount; ++i)
			ppFences[i]->mSubmitted = false;
	}

	FenceStatus util_to_fence_status(GLint status)
	{
		switch (status)
		{
		case GL_SIGNALED: return FENCE_STATUS_COMPLETE;
		case GL_UNSIGNALED: return FENCE_STATUS_INCOMPLETE;
		}
		return FENCE_STATUS_NOTSUBMITTED;
	}

	void getFenceStatus(Renderer* pRenderer, Fence* pFence, FenceStatus* pFenceStatus)
	{
		ASSERT(pRenderer);
		ASSERT(pFence);

		if (!pFence->mSubmitted) {
			*pFenceStatus = FENCE_STATUS_NOTSUBMITTED;
		}
		else {
			GLint status;
			glGetSynciv(pFence->mGlSync, GL_SYNC_STATUS, 1, NULL, &status);
			*pFenceStatus = util_to_fence_status(status);
		}
	}
	/************************************************************************/
	// Utility functions
	/************************************************************************/
	ImageFormat::Enum getRecommendedSwapchainFormat(bool hintHDR)
	{
		return ImageFormat::BGRA8;
	}

	//bool isImageFormatSupported(ImageFormat::Enum format)
	//{
	//}
	/************************************************************************/
	// Execute Indirect Implementation
	/************************************************************************/
	//GLint util_to_gl_indirect_argument_type(IndirectArgumentType argType)
	//{
	//}

	void addIndirectCommandSignature(Renderer* pRenderer, const CommandSignatureDesc* pDesc, CommandSignature** ppCommandSignature)
	{
	}

	void removeIndirectCommandSignature(Renderer* pRenderer, CommandSignature* pCommandSignature)
	{
	}

	void cmdExecuteIndirect(Cmd* pCmd, CommandSignature* pCommandSignature, uint maxCommandCount, Buffer* pIndirectBuffer, uint64_t bufferOffset, Buffer* pCounterBuffer, uint64_t counterBufferOffset)
	{
	}
	/************************************************************************/
	// Query Heap Implementation
	/************************************************************************/
	void getTimestampFrequency(Queue* pQueue, double* pFrequency)
	{
	}

	void addQueryHeap(Renderer* pRenderer, const QueryHeapDesc* pDesc, QueryHeap** ppQueryHeap)
	{
	}

	void removeQueryHeap(Renderer* pRenderer, QueryHeap* pQueryHeap)
	{
	}

	void cmdBeginQuery(Cmd* pCmd, QueryHeap* pQueryHeap, QueryDesc* pQuery)
	{
	}

	void cmdEndQuery(Cmd* pCmd, QueryHeap* pQueryHeap, QueryDesc* pQuery)
	{
	}

	void cmdResolveQuery(Cmd* pCmd, QueryHeap* pQueryHeap, Buffer* pReadbackBuffer, uint32_t startQuery, uint32_t queryCount)
	{
	}
	/************************************************************************/
	// Memory Stats Implementation
	/************************************************************************/
	void calculateMemoryStats(Renderer* pRenderer, char** stats)
	{
	}

	void freeMemoryStats(Renderer* pRenderer, char* stats)
	{
	}
	/************************************************************************/
	// Debug Marker Implementation
	/************************************************************************/
	void cmdBeginDebugMarker(Cmd* pCmd, float r, float g, float b, const char* pName)
	{
	}

	void cmdEndDebugMarker(Cmd* pCmd)
	{
	}

	void cmdAddDebugMarker(Cmd* pCmd, float r, float g, float b, const char* pName)
	{
	}
	/************************************************************************/
	// Resource Debug Naming Interface
	/************************************************************************/
	void setBufferName(Renderer* pRenderer, Buffer* pBuffer, const char* pName)
	{
	}

	void setTextureName(Renderer* pRenderer, Texture* pTexture, const char* pName)
	{
	}
	/************************************************************************/
	/************************************************************************/
#endif // RENDERER_IMPLEMENTATION
#endif
#if defined(__cplusplus) && defined(ENABLE_RENDERER_RUNTIME_SWITCH)
}
#endif
